C51 COMPILER V9.54   MAIN                                                                  12/27/2017 22:11:42 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\keil   55\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\ma
                    -in.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          /***************************************************************************************************
   2          实验功能：第三届国赛试题程序设计
   3          时间：
   4          作者：吴康
   5          ****************************************************************************************************/
   6          #include <STC15F2K60S2.h>
   7          #include <delay.h>
   8          #include <ds1302.h>
   9          #include <iic.h>
  10          #define uchar unsigned char
  11          #define uint unsigned int
  12          
  13          #define TX P10                              //发送
  14          #define RX P11                              //接收
  15          #define somenop1 {_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();}
  16          
  17          uchar code tab[12]={0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90,0xbf,0xff};
  18          uchar dsbuff[8]={11,11,11,11,11,11,11,11};
  19          uchar num[6]={11,11,11,11,11,11};
  20          uchar mima[6]={6,5,4,3,2,1};                //初始密码设置
  21          uchar discount = 0;                         //数码管显示移位变量
  22          uchar ceju_flag=0;                          //定时测距标志变量
  23          uchar mima_flag;                            //密码模式标志位
  24          uchar set=0;                                //设置按键标志位
  25          uchar admit=0;                              //确认按键标志位
  26          uchar reset=0;                              //复位按键标志位
  27          uchar exit=0;                               //退出按键标志位
  28          uchar i=0;                                  //变量
  29          uchar now;                                  //现在的时间存储变量
  30          uchar false;                                //错误的次数标志位
  31          uchar xiang_flag;                           //蜂鸣器响的时间标志位
  32          uchar l_count=4;                            //LED灯闪烁标志位
  33          uchar temp=0;                               //变量
  34          uint distance;                              //距离变量
  35          uchar k;                                    //变量
  36          
  37          /***************************************************************************************************
  38                                                      函数声明
  39          ****************************************************************************************************/
  40          void Timer0Init();
  41          void Timer1Init();
  42          void display();
  43          void keyscan();
  44          void beep(uchar demand);
  45          void relay(uchar demand);
  46          uint get_distance();
  47          void zidongmen();
  48          void mimamen();
  49          void ledctrl(uchar lednum,uchar demand);
  50          void baocunmima();
  51          void readmima();
  52          
  53          /***************************************************************************************************
  54          函数名称：clear
C51 COMPILER V9.54   MAIN                                                                  12/27/2017 22:11:42 PAGE 2   

  55          功能：清除密码函数
  56          ****************************************************************************************************/
  57          void clear()
  58          {
  59   1        for(k=0;k<=5;k++)
  60   1        num[k]=11;
  61   1        i=0;    //特别注意
  62   1      }
  63          
  64          /***************************************************************************************************
  65          函数名称：allinit
  66          功能：板子初始化函数
  67          ****************************************************************************************************/
  68          void allinit()
  69          {
  70   1        P2=0x80;P0=0xff;
  71   1        P2=0xa0;P0=0x00;
  72   1        P2=0xc0;P0=0xff;
  73   1        P2=0xe0;P0=0xff;
  74   1      }
  75          
  76          /***************************************************************************************************
  77          函数名称：main
  78          功能：主函数
  79          ****************************************************************************************************/
  80          void main()
  81          {
  82   1        allinit();                            //板子初始化
  83   1        Timer0Init();                         //定时器0初始化
  84   1        Timer1Init();                         //定时器1初始化
  85   1        dswrite();                            //时钟初始化
  86   1        while(1)
  87   1        {
  88   2          keyscan();                          //按键扫描函数
  89   2          dsread();                           //读取时间
  90   2          if((shijian[2]>=7)&&(shijian[2]<22))//判断时间
  91   2          {
  92   3            mima_flag=0;                      //密码门状态标志位
  93   3            zidongmen();                      //自动门控制函数
  94   3          }
  95   2          else                                //在密码门状态下
  96   2          {
  97   3            mima_flag=1;
  98   3            mimamen();                        //密码门处理函数
  99   3          }
 100   2      
 101   2          if(mima_flag==0)                    //非密码门下显示
 102   2          {
 103   3            dsbuff[0]=shijian[2]/10;
 104   3            dsbuff[1]=shijian[2]%10;
 105   3            dsbuff[2]=10;
 106   3            dsbuff[3]=shijian[1]/10;
 107   3            dsbuff[4]=shijian[1]%10;
 108   3            dsbuff[5]=10;
 109   3            dsbuff[6]=shijian[0]/10;
 110   3            dsbuff[7]=shijian[0]%10;
 111   3          }
 112   2        }
 113   1      }
 114          
 115          /***************************************************************************************************
 116          函数名称：mimamen
C51 COMPILER V9.54   MAIN                                                                  12/27/2017 22:11:42 PAGE 3   

 117          功能：密码门处理函数函数
 118          ****************************************************************************************************/
 119          void mimamen()
 120          {
 121   1        static uchar wancheng_flag=0,j=0,true=0;
 122   1        static uchar true_2=0,false_2=0,flag1=0;
 123   1        if(set==0)                      //没有按下设置键时，显示― ―密码
 124   1        { 
 125   2          dsbuff[0]=10;
 126   2          dsbuff[1]=10;
 127   2          dsbuff[2]=num[0];
 128   2          dsbuff[3]=num[1]; 
 129   2          dsbuff[4]=num[2];
 130   2          dsbuff[5]=num[3];
 131   2          dsbuff[6]=num[4];
 132   2          dsbuff[7]=num[5];
 133   2          if(admit==1)                  //按下确认键后进行对比，看输入的密码是否正确
 134   2          {
 135   3            admit=0;
 136   3            for(j=0;j<=5;j++)
 137   3            {
 138   4              if(num[j]==mima[j])
 139   4                true=1;                 //正确的标志位
 140   4              else 
 141   4              {
 142   5                true=2;                 //不正确的标志位
 143   5              }
 144   4            }
 145   3          }
 146   2          if(true==1)                   //如果正确
 147   2          {
 148   3            relay(1);                   //继电器打开
 149   3            clear();                    //验证通过清除数组里存储的密码
 150   3            if((shijian[0]-now==5)||(60+shijian[0]-now==5))//让继电器通5秒
 151   3            {
 152   4              true=0;                   //清除标志位
 153   4              relay(0);                 //关闭数码管
 154   4            }
 155   3          }
 156   2          else if (true==2)             //如果密码不正确
 157   2          {
 158   3            false++;                    //错误的次数加一，到三次时，报警
 159   3            clear();                    //没输入完成一次都要把数组里存储的数据给清零，不要忘了把i也清零
 160   3            true=0;                     //清除标志位
 161   3          }
 162   2          if(false==3)                  //如果输入密码错误了三次
 163   2          {
 164   3            l_count=0;
 165   3            ledctrl(1,1);
 166   3            beep(1);
 167   3            false=0;
 168   3            admit=0;
 169   3            xiang_flag=1;               //蜂鸣器报警三秒标志位
 170   3      //      if((shijian[0]-now==3)||(60+shijian[0]-now==3))//发蜂鸣器报警三秒
 171   3      //      {
 172   3      //        ledctrl(1,0);
 173   3      //        beep(0);
 174   3      //        false=0;
 175   3      //        admit=0;
 176   3      //      }
 177   3          }
 178   2        }
C51 COMPILER V9.54   MAIN                                                                  12/27/2017 22:11:42 PAGE 4   

 179   1        else //按下设置按键
 180   1        {
 181   2          
 182   2          
 183   2          if(exit==1)                   //退出键功能
 184   2          {
 185   3            exit=0;                     //推出标志位清零
 186   3            true_2=0;
 187   3            set=0;  
 188   3            clear();                    //清空输入密码    
 189   3          }
 190   2          if(true_2==0)                 //设密码时的标志位
 191   2          {
 192   3            dsbuff[0]=11;
 193   3            dsbuff[1]=10;
 194   3            dsbuff[2]=num[0];
 195   3            dsbuff[3]=num[1]; 
 196   3            dsbuff[4]=num[2];
 197   3            dsbuff[5]=num[3];
 198   3            dsbuff[6]=num[4];
 199   3            dsbuff[7]=num[5];
 200   3          }
 201   2          if(true_2==1)                 //这里的admit与后面的admit相冲突 应该把状态判断放在后面 
 202   2          {
 203   3            if(flag1==1) 
 204   3            {
 205   4              clear();
 206   4              flag1=0;
 207   4            }
 208   3            dsbuff[0]=10;
 209   3            dsbuff[1]=11;
 210   3            dsbuff[2]=num[0];
 211   3            dsbuff[3]=num[1];
 212   3            dsbuff[4]=num[2];
 213   3            dsbuff[5]=num[3];
 214   3            dsbuff[6]=num[4];
 215   3            dsbuff[7]=num[5];
 216   3            
 217   3            if(admit==1)
 218   3            {
 219   4              admit=0; 
 220   4              ledctrl(2,1);
 221   4              for(k=0;k<=5;k++)
 222   4              {
 223   5                mima[k]=num[k];
 224   5              }
 225   4              wancheng_flag=1;
 226   4            }
 227   3            if(wancheng_flag==1)
 228   3            {
 229   4              wancheng_flag=0;
 230   4              set=0;
 231   4              true_2=0;
 232   4              ledctrl(1,1);
 233   4              clear();
 234   4            }//设置完后清空标志位   
 235   3          }   
 236   2          if(admit==1)
 237   2          {
 238   3            admit=0;
 239   3            for(k=0;k<=5;k++)
 240   3            {
C51 COMPILER V9.54   MAIN                                                                  12/27/2017 22:11:42 PAGE 5   

 241   4              if(num[k]==mima[k])
 242   4                {
 243   5                  true_2=1;
 244   5                  flag1=1;
 245   5                }
 246   4              else 
 247   4                {
 248   5                  true_2=2;
 249   5                  clear();
 250   5                } //这个地方改变了true2的状态 
 251   4            } 
 252   3          }
 253   2          if(true_2==2)
 254   2          {
 255   3            false_2++;
 256   3            clear();
 257   3            true_2=0;
 258   3          }
 259   2          if(false_2==3)//在设置时错误了三次
 260   2          {
 261   3            set=0;
 262   3            ledctrl(2,1);
 263   3            beep(1);
 264   3            xiang_flag=1;
 265   3            false_2=0;  
 266   3          }
 267   2        }
 268   1      
 269   1        if(reset==1)//按下复位按键
 270   1        {
 271   2          reset=0;
 272   2          for(k=0;k<=5;k++)
 273   2          {
 274   3            mima[k]=6-k;
 275   3          }
 276   2        }
 277   1      }
 278          
 279          /***************************************************************************************************
 280          函数名称：zidongmen
 281          功能：自动门处理函数函数
 282          ****************************************************************************************************/
 283          void zidongmen()
 284          {
 285   1          static bit kai_flag=0;
 286   1          if(ceju_flag==1)
 287   1          {
 288   2            ceju_flag=0;
 289   2            distance=get_distance();
 290   2          } 
 291   1          if((distance<30)&&(kai_flag==0))
 292   1          {
 293   2            kai_flag=1;//开门的标志位
 294   2            temp=shijian[0];//将此时的时间赋值给temp
 295   2          }
 296   1          if(kai_flag==1)
 297   1          {
 298   2            relay(1);//开门打开继电器
 299   2            if((shijian[0]-temp==5)||(60+shijian[0]-temp==5))
 300   2            {
 301   3              kai_flag=0;
 302   3              relay(0);//5秒后关闭继电器
C51 COMPILER V9.54   MAIN                                                                  12/27/2017 22:11:42 PAGE 6   

 303   3            } 
 304   2          }
 305   1      }
 306          
 307          /***************************************************************************************************
 308          函数名称：keyscan
 309          功能：按键处理函数函数
 310          ****************************************************************************************************/
 311          void keyscan()
 312          {
 313   1        uchar temp;
 314   1        P3=0x7f;P44=0;P42=1;
 315   1        temp=P3;
 316   1        temp=P3&0x0f;
 317   1        if(temp!=0x0f)
 318   1        {
 319   2          Delay5ms();
 320   2          temp=P3&0x0f;
 321   2          if(temp!=0x0f)
 322   2          {
 323   3            switch(temp)
 324   3            {
 325   4              case 0x0e:if(i<=5){num[i]=0;i++;}break;
 326   4              case 0x0d:if(i<=5){num[i]=4;i++;}break;
 327   4              case 0x0b:if(i<=5){num[i]=8;i++;}break;
 328   4              case 0x07:break;
 329   4            }
 330   3          }
 331   2          while(temp!=0x0f)
 332   2          {
 333   3            temp=P3;
 334   3            temp=P3&0x0f;
 335   3          }
 336   2        }
 337   1      
 338   1        P3=0xbf;P44=1;P42=0;
 339   1        temp=P3;
 340   1        temp=P3&0x0f;
 341   1        if(temp!=0x0f)
 342   1        {
 343   2          Delay5ms();
 344   2          temp=P3&0x0f;
 345   2          if(temp!=0x0f)
 346   2          {
 347   3            switch(temp)
 348   3            {
 349   4              case 0x0e:if(i<=5){num[i]=1;i++;}break;
 350   4              case 0x0d:if(i<=5){num[i]=5;i++;}break;
 351   4              case 0x0b:if(i<=5){num[i]=9;i++;}break;
 352   4              case 0x07:
 353   4              if(admit==0)
 354   4              {
 355   5                if(i>=1)
 356   5                {
 357   6                  i=i-1;
 358   6                  num[i]=11;
 359   6                }
 360   5              }
 361   4              break;
 362   4            }
 363   3          }
 364   2            while(P3!=0xbf);
C51 COMPILER V9.54   MAIN                                                                  12/27/2017 22:11:42 PAGE 7   

 365   2        } 
 366   1      
 367   1        P3=0xdf;P44=1;P42=1;
 368   1        temp=P3;
 369   1        temp=P3&0x0f;
 370   1        if(temp!=0x0f)
 371   1        {
 372   2          Delay5ms();
 373   2          temp=P3&0x0f;
 374   2          if(temp!=0x0f)
 375   2          {
 376   3            temp=P3&0x0f;
 377   3            switch(temp)
 378   3            {
 379   4              case 0x0e:if(i<=5){num[i]=2;i++;}break;
 380   4              case 0x0d:if(i<=5){num[i]=6;i++;}break;
 381   4              case 0x0b:if(set==0) clear(); set=1;admit=0;break;
 382   4              case 0x07:if(i==6){admit=1;now=shijian[0];}break;
 383   4            }
 384   3          }
 385   2          while(P3!=0xdf);
 386   2        }
 387   1      
 388   1        P3=0xef;
 389   1        temp=P3;
 390   1        temp=P3&0x0f;
 391   1        if(temp!=0x0f)
 392   1        {
 393   2          Delay5ms();
 394   2          temp=P3&0x0f;
 395   2          if(temp!=0x0f)
 396   2          {
 397   3            switch(temp)
 398   3            {
 399   4              case 0x0e:if(i<=5){num[i]=3;i++;}break;
 400   4              case 0x0d:if(i<=5){num[i]=7;i++;}break;
 401   4              case 0x0b:reset=1;break;
 402   4              case 0x07:exit=1;break;
 403   4            }
 404   3          }
 405   2          while(P3!=0xef);
 406   2        }
 407   1      }
 408          
 409          /***************************************************************************************************
 410          函数名称：Timer0Init
 411          功能：定时器0初始化函数
 412          ****************************************************************************************************/
 413          void Timer0Init(void)   //2毫秒@11.0592MHz
 414          {
 415   1        AUXR |= 0x80;         //定时器时钟1T模式
 416   1        TMOD &= 0xF0;         //设置定时器模式
 417   1        TL0 = 0x9A;           //设置定时初值
 418   1        TH0 = 0xA9;           //设置定时初值
 419   1        TF0 = 0;              //清除TF0标志
 420   1        TR0 = 1;              //定时器0开始计时
 421   1        EA=1;
 422   1        ET0=1;
 423   1      }
 424          
 425          /***************************************************************************************************
 426          函数名称：display
C51 COMPILER V9.54   MAIN                                                                  12/27/2017 22:11:42 PAGE 8   

 427          功能：数码管显示函数
 428          ****************************************************************************************************/
 429          void display()
 430          {
 431   1        P2=(P2&0x1f)|0xe0;
 432   1        P0=0xff;
 433   1        P2=P2&0x1f;
 434   1        
 435   1        P2=(P2&0x1f)|0xc0;
 436   1        P0=1<<discount;
 437   1        P2=P2&0x1f;
 438   1        
 439   1        P2=(P2&0x1f)|0xe0;
 440   1        P0=tab[dsbuff[discount]];
 441   1        P2=P2&0x1f;
 442   1        if(++discount==8) discount=0;
 443   1      }
 444          
 445          /***************************************************************************************************
 446          函数名称：relay
 447          功能：继电器控制函数
 448          ****************************************************************************************************/
 449          void relay(uchar demand)
 450          {
 451   1        static uchar relay_state=0;
 452   1        if((demand==1)&&(relay_state==0))
 453   1        {
 454   2          relay_state=1;
 455   2          P2=(P2&0x1f)|0xa0;
 456   2          P0=0x10;
 457   2          P2=P2&0x1f;
 458   2        }
 459   1        else if((demand==0)&&(relay_state==1))
 460   1        {
 461   2          relay_state=0;
 462   2          P2=(P2&0x1f)|0xa0;
 463   2          P0=0x00;
 464   2          P2=P2&0x1f;
 465   2        }
 466   1      }
 467          
 468          /***************************************************************************************************
 469          函数名称：beep
 470          功能：蜂鸣器控制函数
 471          ****************************************************************************************************/
 472          void beep(uchar demand)
 473          {
 474   1        static uchar beep_state=0;
 475   1        if((demand==1)&&(beep_state==0))
 476   1        {
 477   2          beep_state=1;
 478   2          P2=(P2&0x1f)|0xa0;
 479   2          P0=0x40;
 480   2          P2=P2&0x1f;
 481   2        }
 482   1        else if((demand==0)&&(beep_state==1))
 483   1        {
 484   2          beep_state=0;
 485   2          P2=(P2&0x1f)|0xa0;
 486   2          P0=0x00;
 487   2          P2=P2&0x1f;
 488   2        }
C51 COMPILER V9.54   MAIN                                                                  12/27/2017 22:11:42 PAGE 9   

 489   1      }
 490          
 491          /***************************************************************************************************
 492          函数名称：ledctrl
 493          功能：led控制函数
 494          ****************************************************************************************************/
 495          void ledctrl(uchar lednum,uchar demand)
 496          {
 497   1        static uchar led_state=0;
 498   1        uchar n;
 499   1        lednum--;
 500   1        n=led_state&(0x01<<lednum);
 501   1        if((n==0)&&(demand==1))
 502   1        {
 503   2          led_state=0x01<<lednum;
 504   2          P2=(P2&0x1f)|0x80;
 505   2          P0=~(0x01<<lednum);
 506   2          P2=P2&0x1f;
 507   2        }
 508   1        else if((n>0)&&(demand==0))
 509   1        {
 510   2          led_state=0;
 511   2          P2=(P2&0x1f)|0x80;
 512   2          P0=0xff;
 513   2          P2=P2&0x1f;
 514   2        }
 515   1      }
 516          
 517          /***************************************************************************************************
 518          函数名称：sendwave
 519          功能：产生波形函数
 520          ****************************************************************************************************/
 521          void sendwave()
 522          {
 523   1        TX=1;
 524   1        somenop1;somenop1;somenop1;somenop1;somenop1;
 525   1        somenop1;somenop1;somenop1;somenop1;somenop1;
 526   1        TX=0;
 527   1      }
 528          
 529          /***************************************************************************************************
 530          函数名称：get_distance
 531          功能：距离计算函数
 532          ****************************************************************************************************/
 533          uint get_distance()
 534          {
 535   1        uint dis;
 536   1        sendwave();
 537   1        TR1=1;
 538   1        while((RX==1)&&(TF1==0));
 539   1        TR1=0;
 540   1        if(TF1)
 541   1        {
 542   2          TF1=0;
 543   2          dis=999;
 544   2        }
 545   1        else 
 546   1        {
 547   2          dis=(TH1<<8)|TL1;
 548   2          dis=dis*0.017;
 549   2        }
 550   1        TH1=TL1=0;
C51 COMPILER V9.54   MAIN                                                                  12/27/2017 22:11:42 PAGE 10  

 551   1        return dis; 
 552   1      }
 553          
 554          /***************************************************************************************************
 555          函数名称：Timer1Init
 556          功能：定时器1初始化函数
 557          ****************************************************************************************************/
 558          void Timer1Init(void)   //0微秒@11.0592MHz
 559          {
 560   1        AUXR &= 0xBF;         //定时器时钟12T模式
 561   1        TMOD &= 0x0F;         //设置定时器模式
 562   1        TL1 = 0x00;           //设置定时初值
 563   1        TH1 = 0x00;           //设置定时初值
 564   1        TF1 = 0;              //清除TF1标志
 565   1        TR1 = 0;              //定时器1开始计时
 566   1      }
 567          
 568          /***************************************************************************************************
 569          函数名称：Timer0
 570          功能：定时器0中断服务函数
 571          ****************************************************************************************************/
 572          void time_0() interrupt 1
 573          {
 574   1        static uchar ss1=0;
 575   1        static uint ss2=0;
 576   1        static uchar ss3,s_flag;
 577   1        display();
 578   1        if(++ss1==100)
 579   1        {
 580   2          ss1=0;
 581   2          ceju_flag=1;
 582   2        }
 583   1        if(xiang_flag==1)
 584   1        {
 585   2          if(++ss2==1500)       
 586   2          {
 587   3            ss2=0;
 588   3            ledctrl(2,0); 
 589   3            beep(0);
 590   3            xiang_flag=0;
 591   3          }
 592   2        }
 593   1        if(l_count==0)
 594   1        {
 595   2          if(++ss3==200)
 596   2          {
 597   3            ss3=0;
 598   3            ledctrl(1,0);
 599   3            l_count=4;
 600   3          }
 601   2        }
 602   1        if(l_count<=2)//闪烁三次
 603   1        {
 604   2            if(++ss3==200)
 605   2            {
 606   3              ss3=0;
 607   3              if(s_flag==0)
 608   3              {
 609   4                s_flag=1;
 610   4                ledctrl(1,1);
 611   4              }
 612   3              else
C51 COMPILER V9.54   MAIN                                                                  12/27/2017 22:11:42 PAGE 11  

 613   3              {
 614   4                s_flag=0;
 615   4                ledctrl(1,0);
 616   4                l_count++;
 617   4              }
 618   3            }
 619   2        }
 620   1      }
 621          
 622          
 623          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1696    ----
   CONSTANT SIZE    =     12    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     50    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
