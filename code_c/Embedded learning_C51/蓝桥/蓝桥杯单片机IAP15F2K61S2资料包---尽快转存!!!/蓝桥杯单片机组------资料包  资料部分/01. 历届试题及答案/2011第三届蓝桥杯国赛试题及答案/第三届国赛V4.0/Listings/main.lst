C51 COMPILER V9.54   MAIN                                                                  12/27/2017 19:14:47 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\keil   55\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\ma
                    -in.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <STC15F2K60S2.h>
   2          #include <delay.h>
   3          #include <ds1302.h>
   4          
   5          #define uchar unsigned char
   6          #define uint unsigned int
   7          
   8          #define TX P10
   9          #define RX P11
  10          #define somenop1 {_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();}
  11          
  12          uchar code tab[12]={0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90,0xbf,0xff};
  13          uchar dsbuff[8]={11,11,11,11,11,11,11,11};
  14          uchar num[6]={11,11,11,11,11,11};
  15          uchar mima[6]={6,5,4,3,2,1};
  16          uchar discount = 0,ceju_flag=0,mima_flag;
  17          uchar set=0,admit=0,reset=0,exit=0,i=0;
  18          uchar now;
  19          uchar false;
  20          uchar xiang_flag;
  21          uchar l_count=4;
  22          uchar temp=0;
  23          uint distance;
  24          uchar k;
  25          
  26          void Timer0Init();
  27          void Timer1Init();
  28          void display();
  29          void keyscan();
  30          void beep(uchar demand);
  31          void relay(uchar demand);
  32          uint get_distance();
  33          void zidongmen();
  34          void mimamen();
  35          void ledctrl(uchar lednum,uchar demand);
  36          
  37          void clear()
  38          {
  39   1        for(k=0;k<=5;k++)
  40   1        num[k]=11;
  41   1        i=0;    //特别注意
  42   1      }
  43          
  44          void allinit()
  45          {
  46   1        P2=0x80;P0=0xff;
  47   1        P2=0xa0;P0=0x00;
  48   1        P2=0xc0;P0=0xff;
  49   1        P2=0xe0;P0=0xff;
  50   1      }
  51          
  52          void main()
  53          {
  54   1        allinit();//板子初始化
C51 COMPILER V9.54   MAIN                                                                  12/27/2017 19:14:47 PAGE 2   

  55   1        Timer0Init();//定时器0初始化
  56   1        Timer1Init(); //定时器1初始化
  57   1        dswrite();//时钟初始化
  58   1        while(1)
  59   1        {
  60   2          keyscan();//按键扫描函数
  61   2          dsread();//读取时间
  62   2          if((shijian[2]>=7)&&(shijian[2]<22))//判断时间
  63   2          {
  64   3            mima_flag=0;//密码门状态标志位
  65   3            zidongmen();//自动门控制函数
  66   3          }
  67   2          else //在密码门状态下
  68   2          {
  69   3            mima_flag=1;
  70   3            mimamen();//密码门处理函数
  71   3          }
  72   2      
  73   2          if(mima_flag==0)  //非密码门下显示
  74   2          {
  75   3            dsbuff[0]=shijian[2]/10;
  76   3            dsbuff[1]=shijian[2]%10;
  77   3            dsbuff[2]=10;
  78   3            dsbuff[3]=shijian[1]/10;
  79   3            dsbuff[4]=shijian[1]%10;
  80   3            dsbuff[5]=10;
  81   3            dsbuff[6]=shijian[0]/10;
  82   3            dsbuff[7]=shijian[0]%10;
  83   3          }
  84   2        }
  85   1      }
  86          void mimamen()
  87          {
  88   1        static uchar wancheng_flag=0,j=0,true=0;
  89   1        static uchar true_2=0,false_2=0,flag1=0;
  90   1        if(set==0)//没有按下设置键时，显示― ―密码
  91   1        {
  92   2          dsbuff[0]=10;
  93   2          dsbuff[1]=10;
  94   2          dsbuff[2]=num[0];
  95   2          dsbuff[3]=num[1]; 
  96   2          dsbuff[4]=num[2];
  97   2          dsbuff[5]=num[3];
  98   2          dsbuff[6]=num[4];
  99   2          dsbuff[7]=num[5];
 100   2          if(admit==1)//按下确认键后进行对比，看输入的密码是否正确
 101   2          {
 102   3            admit=0;
 103   3            for(j=0;j<=5;j++)
 104   3            {
 105   4              if(num[j]==mima[j])
 106   4                true=1;//正确的标志位
 107   4              else 
 108   4              {
 109   5                true=2;//不正确的标志位
 110   5              }
 111   4            }
 112   3          }
 113   2          if(true==1)//如果正确
 114   2          {
 115   3            relay(1);//继电器打开
 116   3            clear();//验证通过清除数组里存储的密码
C51 COMPILER V9.54   MAIN                                                                  12/27/2017 19:14:47 PAGE 3   

 117   3            if((shijian[0]-now==5)||(60+shijian[0]-now==5))//让继电器通5秒
 118   3            {
 119   4              true=0;//清除标志位
 120   4              relay(0);//关闭数码管
 121   4            }
 122   3          }
 123   2          else if (true==2)//如果密码不正确
 124   2          {
 125   3            false++;//错误的次数加一，到三次时，报警
 126   3            clear();//没输入完成一次都要把数组里存储的数据给清零，不要忘了把i也清零
 127   3            true=0;//清除标志位
 128   3          }
 129   2          if(false==3)//如果输入密码错误了三次
 130   2          {
 131   3            l_count=0;
 132   3            ledctrl(1,1);
 133   3            beep(1);
 134   3            false=0;
 135   3            admit=0;
 136   3            xiang_flag=1;//蜂鸣器报警三秒标志位
 137   3      //      if((shijian[0]-now==3)||(60+shijian[0]-now==3))//发蜂鸣器报警三秒
 138   3      //      {
 139   3      //        ledctrl(1,0);
 140   3      //        beep(0);
 141   3      //        false=0;
 142   3      //        admit=0;
 143   3      //      }
 144   3          }
 145   2        }
 146   1        else //按下设置按键
 147   1        {
 148   2          if(exit==1)//退出键功能
 149   2          {
 150   3            exit=0;//推出标志位清零
 151   3            true_2=0;
 152   3            set=0;  
 153   3            clear(); //清空输入密码   
 154   3          }
 155   2          if(true_2==0)//设密码时的标志位
 156   2          {
 157   3            dsbuff[0]=11;
 158   3            dsbuff[1]=10;
 159   3            dsbuff[2]=num[0];
 160   3            dsbuff[3]=num[1]; 
 161   3            dsbuff[4]=num[2];
 162   3            dsbuff[5]=num[3];
 163   3            dsbuff[6]=num[4];
 164   3            dsbuff[7]=num[5];
 165   3          }
 166   2          if(true_2==1)   //这里的admit与后面的admit相冲突 应该把状态判断放在后面 
 167   2          {
 168   3            if(flag1==1) 
 169   3            {
 170   4              clear();
 171   4              flag1=0;
 172   4            }
 173   3            dsbuff[0]=10;
 174   3            dsbuff[1]=11;
 175   3            dsbuff[2]=num[0];
 176   3            dsbuff[3]=num[1];
 177   3            dsbuff[4]=num[2];
 178   3            dsbuff[5]=num[3];
C51 COMPILER V9.54   MAIN                                                                  12/27/2017 19:14:47 PAGE 4   

 179   3            dsbuff[6]=num[4];
 180   3            dsbuff[7]=num[5];
 181   3            
 182   3            if(admit==1)
 183   3            {
 184   4              admit=0; 
 185   4              ledctrl(2,1);
 186   4              for(k=0;k<=5;k++)
 187   4              {
 188   5                mima[k]=num[k];
 189   5              }
 190   4              wancheng_flag=1;
 191   4            }
 192   3            if(wancheng_flag==1)
 193   3            {
 194   4              wancheng_flag=0;
 195   4              set=0;
 196   4              true_2=0;
 197   4              ledctrl(1,1);
 198   4              clear();
 199   4            }//设置完后清空标志位   
 200   3          }   
 201   2          if(admit==1)
 202   2          {
 203   3            admit=0;
 204   3            for(k=0;k<=5;k++)
 205   3            {
 206   4              if(num[k]==mima[k])
 207   4                {
 208   5                  true_2=1;
 209   5                  flag1=1;
 210   5                }
 211   4              else 
 212   4                {
 213   5                  true_2=2;
 214   5                  clear();
 215   5                } //这个地方改变了true2的状态 
 216   4            } 
 217   3          }
 218   2          if(true_2==2)
 219   2          {
 220   3            false_2++;
 221   3            clear();
 222   3            true_2=0;
 223   3          }
 224   2          if(false_2==3)//在设置时错误了三次
 225   2          {
 226   3            set=0;
 227   3            ledctrl(2,1);
 228   3            beep(1);
 229   3            xiang_flag=1;
 230   3            false_2=0;  
 231   3          }
 232   2        }
 233   1      
 234   1        if(reset==1)//按下复位按键
 235   1        {
 236   2          reset=0;
 237   2          for(k=0;k<=5;k++)
 238   2          {
 239   3            mima[k]=6-k;
 240   3          }
C51 COMPILER V9.54   MAIN                                                                  12/27/2017 19:14:47 PAGE 5   

 241   2        }
 242   1      }
 243          
 244          void zidongmen()
 245          {
 246   1          static bit kai_flag=0;
 247   1          if(ceju_flag==1)
 248   1          {
 249   2            ceju_flag=0;
 250   2            distance=get_distance();
 251   2          } 
 252   1          if((distance<30)&&(kai_flag==0))
 253   1          {
 254   2            kai_flag=1;//开门的标志位
 255   2            temp=shijian[0];//将此时的时间赋值给temp
 256   2          }
 257   1          if(kai_flag==1)
 258   1          {
 259   2            relay(1);//开门打开继电器
 260   2            if((shijian[0]-temp==5)||(60+shijian[0]-temp==5))
 261   2            {
 262   3              kai_flag=0;
 263   3              relay(0);//5秒后关闭继电器
 264   3            } 
 265   2          }
 266   1      }
 267          void keyscan()
 268          {
 269   1        uchar temp;
 270   1        P3=0x7f;P44=0;P42=1;
 271   1        temp=P3;
 272   1        temp=P3&0x0f;
 273   1        if(temp!=0x0f)
 274   1        {
 275   2          Delay5ms();
 276   2          temp=P3&0x0f;
 277   2          if(temp!=0x0f)
 278   2          {
 279   3            switch(temp)
 280   3            {
 281   4              case 0x0e:if(i<=5){num[i]=0;i++;}break;
 282   4              case 0x0d:if(i<=5){num[i]=4;i++;}break;
 283   4              case 0x0b:if(i<=5){num[i]=8;i++;}break;
 284   4              case 0x07:break;
 285   4            }
 286   3          }
 287   2          while(temp!=0x0f)
 288   2          {
 289   3            temp=P3;
 290   3            temp=P3&0x0f;
 291   3          }
 292   2        }
 293   1      
 294   1        P3=0xbf;P44=1;P42=0;
 295   1        temp=P3;
 296   1        temp=P3&0x0f;
 297   1        if(temp!=0x0f)
 298   1        {
 299   2          Delay5ms();
 300   2          temp=P3&0x0f;
 301   2          if(temp!=0x0f)
 302   2          {
C51 COMPILER V9.54   MAIN                                                                  12/27/2017 19:14:47 PAGE 6   

 303   3            switch(temp)
 304   3            {
 305   4              case 0x0e:if(i<=5){num[i]=1;i++;}break;
 306   4              case 0x0d:if(i<=5){num[i]=5;i++;}break;
 307   4              case 0x0b:if(i<=5){num[i]=9;i++;}break;
 308   4              case 0x07:
 309   4              if(admit==0)
 310   4              {
 311   5                if(i>=1)
 312   5                {
 313   6                  i=i-1;
 314   6                  num[i]=11;
 315   6                }
 316   5              }
 317   4              break;
 318   4            }
 319   3          }
 320   2            while(P3!=0xbf);
 321   2        } 
 322   1      
 323   1        P3=0xdf;P44=1;P42=1;
 324   1        temp=P3;
 325   1        temp=P3&0x0f;
 326   1        if(temp!=0x0f)
 327   1        {
 328   2          Delay5ms();
 329   2          temp=P3&0x0f;
 330   2          if(temp!=0x0f)
 331   2          {
 332   3            temp=P3&0x0f;
 333   3            switch(temp)
 334   3            {
 335   4              case 0x0e:if(i<=5){num[i]=2;i++;}break;
 336   4              case 0x0d:if(i<=5){num[i]=6;i++;}break;
 337   4              case 0x0b:if(set==0) clear(); set=1;admit=0;break;
 338   4              case 0x07:if(i==6){admit=1;now=shijian[0];}break;
 339   4            }
 340   3          }
 341   2          while(P3!=0xdf);
 342   2        }
 343   1      
 344   1        P3=0xef;
 345   1        temp=P3;
 346   1        temp=P3&0x0f;
 347   1        if(temp!=0x0f)
 348   1        {
 349   2          Delay5ms();
 350   2          temp=P3&0x0f;
 351   2          if(temp!=0x0f)
 352   2          {
 353   3            switch(temp)
 354   3            {
 355   4              case 0x0e:if(i<=5){num[i]=3;i++;}break;
 356   4              case 0x0d:if(i<=5){num[i]=7;i++;}break;
 357   4              case 0x0b:reset=1;break;
 358   4              case 0x07:exit=1;break;
 359   4            }
 360   3          }
 361   2          while(P3!=0xef);
 362   2        }
 363   1      }
 364          
C51 COMPILER V9.54   MAIN                                                                  12/27/2017 19:14:47 PAGE 7   

 365          void Timer0Init(void)   //2毫秒@11.0592MHz
 366          {
 367   1        AUXR |= 0x80;         //定时器时钟1T模式
 368   1        TMOD &= 0xF0;         //设置定时器模式
 369   1        TL0 = 0x9A;           //设置定时初值
 370   1        TH0 = 0xA9;           //设置定时初值
 371   1        TF0 = 0;              //清除TF0标志
 372   1        TR0 = 1;              //定时器0开始计时
 373   1        EA=1;
 374   1        ET0=1;
 375   1      }
 376          
 377          void display()
 378          {
 379   1        P2=(P2&0x1f)|0xe0;
 380   1        P0=0xff;
 381   1        P2=P2&0x1f;
 382   1        
 383   1        P2=(P2&0x1f)|0xc0;
 384   1        P0=1<<discount;
 385   1        P2=P2&0x1f;
 386   1        
 387   1        P2=(P2&0x1f)|0xe0;
 388   1        P0=tab[dsbuff[discount]];
 389   1        P2=P2&0x1f;
 390   1        if(++discount==8) discount=0;
 391   1      }
 392          
 393          void relay(uchar demand)
 394          {
 395   1        static uchar relay_state=0;
 396   1        if((demand==1)&&(relay_state==0))
 397   1        {
 398   2          relay_state=1;
 399   2          P2=(P2&0x1f)|0xa0;
 400   2          P0=0x10;
 401   2          P2=P2&0x1f;
 402   2        }
 403   1        else if((demand==0)&&(relay_state==1))
 404   1        {
 405   2          relay_state=0;
 406   2          P2=(P2&0x1f)|0xa0;
 407   2          P0=0x00;
 408   2          P2=P2&0x1f;
 409   2        }
 410   1      }
 411          
 412          void beep(uchar demand)
 413          {
 414   1        static uchar beep_state=0;
 415   1        if((demand==1)&&(beep_state==0))
 416   1        {
 417   2          beep_state=1;
 418   2          P2=(P2&0x1f)|0xa0;
 419   2          P0=0x40;
 420   2          P2=P2&0x1f;
 421   2        }
 422   1        else if((demand==0)&&(beep_state==1))
 423   1        {
 424   2          beep_state=0;
 425   2          P2=(P2&0x1f)|0xa0;
 426   2          P0=0x00;
C51 COMPILER V9.54   MAIN                                                                  12/27/2017 19:14:47 PAGE 8   

 427   2          P2=P2&0x1f;
 428   2        }
 429   1      }
 430          
 431          void ledctrl(uchar lednum,uchar demand)
 432          {
 433   1        static uchar led_state=0;
 434   1        uchar n;
 435   1        lednum--;
 436   1        n=led_state&(0x01<<lednum);
 437   1        if((n==0)&&(demand==1))
 438   1        {
 439   2          led_state=0x01<<lednum;
 440   2          P2=(P2&0x1f)|0x80;
 441   2          P0=~(0x01<<lednum);
 442   2          P2=P2&0x1f;
 443   2        }
 444   1        else if((n>0)&&(demand==0))
 445   1        {
 446   2          led_state=0;
 447   2          P2=(P2&0x1f)|0x80;
 448   2          P0=0xff;
 449   2          P2=P2&0x1f;
 450   2        }
 451   1      }
 452          
 453          void sendwave()
 454          {
 455   1        TX=1;
 456   1        somenop1;somenop1;somenop1;somenop1;somenop1;
 457   1        somenop1;somenop1;somenop1;somenop1;somenop1;
 458   1        TX=0;
 459   1      }
 460          
 461          uint get_distance()
 462          {
 463   1        uint dis;
 464   1        sendwave();
 465   1        TR1=1;
 466   1        while((RX==1)&&(TF1==0));
 467   1        TR1=0;
 468   1        if(TF1)
 469   1        {
 470   2          TF1=0;
 471   2          dis=999;
 472   2        }
 473   1        else 
 474   1        {
 475   2          dis=(TH1<<8)|TL1;
 476   2          dis=dis*0.017;
 477   2        }
 478   1        TH1=TL1=0;
 479   1        return dis; 
 480   1      }
 481          
 482          void Timer1Init(void)   //0微秒@11.0592MHz
 483          {
 484   1        AUXR &= 0xBF;         //定时器时钟12T模式
 485   1        TMOD &= 0x0F;         //设置定时器模式
 486   1        TL1 = 0x00;           //设置定时初值
 487   1        TH1 = 0x00;           //设置定时初值
 488   1        TF1 = 0;              //清除TF1标志
C51 COMPILER V9.54   MAIN                                                                  12/27/2017 19:14:47 PAGE 9   

 489   1        TR1 = 0;              //定时器1开始计时
 490   1      }
 491          
 492          void time_0() interrupt 1
 493          {
 494   1        static uchar ss1=0;
 495   1        static uint ss2=0;
 496   1        static uchar ss3,s_flag;
 497   1        display();
 498   1        if(++ss1==100)
 499   1        {
 500   2          ss1=0;
 501   2          ceju_flag=1;
 502   2        }
 503   1        if(xiang_flag==1)
 504   1        {
 505   2          if(++ss2==1500)       
 506   2          {
 507   3            ss2=0;
 508   3            ledctrl(2,0); 
 509   3            beep(0);
 510   3            xiang_flag=0;
 511   3          }
 512   2        }
 513   1        if(l_count==0)
 514   1        {
 515   2          if(++ss3==200)
 516   2          {
 517   3            ss3=0;
 518   3            ledctrl(1,0);
 519   3            l_count=4;
 520   3          }
 521   2        }
 522   1        if(l_count<=2)//闪烁三次
 523   1        {
 524   2            if(++ss3==200)
 525   2            {
 526   3              ss3=0;
 527   3              if(s_flag==0)
 528   3              {
 529   4                s_flag=1;
 530   4                ledctrl(1,1);
 531   4              }
 532   3              else
 533   3              {
 534   4                s_flag=0;
 535   4                ledctrl(1,0);
 536   4                l_count++;
 537   4              }
 538   3            }
 539   2        }
 540   1      }
 541          
 542          
 543          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1696    ----
   CONSTANT SIZE    =     12    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
C51 COMPILER V9.54   MAIN                                                                  12/27/2017 19:14:47 PAGE 10  

   DATA SIZE        =     50    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
