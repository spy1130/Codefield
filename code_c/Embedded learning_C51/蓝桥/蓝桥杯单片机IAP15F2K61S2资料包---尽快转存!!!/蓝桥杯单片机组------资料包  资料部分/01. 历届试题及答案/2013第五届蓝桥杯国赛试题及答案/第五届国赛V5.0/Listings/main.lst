C51 COMPILER V9.54   MAIN                                                                  12/27/2017 19:52:22 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\keil   55\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\ma
                    -in.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <STC15F2K60S2.h>
   2          #include <delay.h>
   3          #include <iic.h>
   4          #include <onewire.h>
   5          #include <ds1302.h>
   6          #include <stdio.h>
   7          
   8          #define uchar unsigned char 
   9          #define uint unsigned int
  10          
  11          uchar ori_time,fin_time,jc_time;
  12          uint shi_count,fasong_count;
  13          uchar code tab[13]={0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90,0xbf,0xff,0xc6};
  14          uchar dsbuff[8]={11,11,11,11,11,11,11,11};
  15          uchar discount;
  16          uchar code ledwdata[]={0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80}; 
  17          uchar yi,er,san,si,wu,liu,qi,ba;
  18          pdata uchar s4=0,s5=0,s6=0,s7=0;
  19          uchar ad_count,ad_flag,shidu,tem,ad_count_2,ad_flag_2;
  20          uchar light_strength,light_state;
  21          uchar shi_xian,wen_xian,ting_xian;
  22          uchar led_status,fasong_flag;
  23          pdata char a[25];
  24          char shuju[6];
  25          uchar n,last_light;
  26          uchar jiechu_flag,num;
  27          uchar i=0;
  28          uchar ADD=0x00,WADD=0x00;
  29          uchar yanzheng=0;
  30          
  31          void Timer0Init(void);
  32          void keyscan();
  33          void display();
  34          void wendu_xianshi();
  35          void shizhong_xianshi();
  36          void tingzhi_xianshi();
  37          void led(uchar lednum,uchar demand);
  38          void UartInit(void);
  39          void chuangshu();
  40          void sendstring(uchar *p);
  41          void jilu();
  42          void jisuan();
  43          //void display1(uchar yi,uchar er);
  44          //void display2(uchar san,uchar si);
  45          //void display3(uchar wu,uchar liu);
  46          //void display4(uchar qi,uchar ba);
  47          //void Display(uchar dp);
  48          void L_ED(uchar liang);
  49          
  50          void allinit()
  51          {
  52   1        P2=0x80;P0=0xff;
  53   1        P2=0xa0;P0=0x00;          
  54   1        P2=0xc0;P0=0xff;
C51 COMPILER V9.54   MAIN                                                                  12/27/2017 19:52:22 PAGE 2   

  55   1        P2=0xe0;P0=0xff;
  56   1      }
  57          
  58          void main()
  59          {
  60   1        allinit();
  61   1        Timer0Init();
  62   1        UartInit(); 
  63   1        EA=1;
  64   1        ET0=1;
  65   1        ES=1;
  66   1        dswrite();
  67   1        while(1)
  68   1        {
  69   2          keyscan();
  70   2          
  71   2          tem=wendu();
  72   2          if(ad_flag==1)
  73   2          {
  74   3            shidu=adread(0x03);
  75   3            shidu=adread(0x03);
  76   3            ad_flag=0;
  77   3          }
  78   2          if(ad_flag_2==1)
  79   2          {
  80   3            ad_flag_2=0;
  81   3            dsread();   //时钟显示如果会抖动 则空个100Ms或50ms去读取 则不抖
  82   3            last_light=light_strength;
  83   3            light_strength=adread(0x01);
  84   3            light_strength=adread(0x01);
  85   3            jisuan();  
  86   3          }
  87   2      
  88   2          switch(s5)
  89   2          {
  90   3            case 0: wen_xian=1;shi_xian=0;ting_xian=0;break;
  91   3            case 1: wen_xian=0;shi_xian=1;ting_xian=0;break;
  92   3            case 2: wen_xian=0;shi_xian=0;ting_xian=1;break;
  93   3            case 3: s5=0;break;
  94   3          }
  95   2          if((wen_xian==1)&&(shi_xian==0)&&(ting_xian==0))
  96   2          {  
  97   3            wendu_xianshi();
  98   3          }
  99   2          else if((wen_xian==0)&&(shi_xian==1)&&(ting_xian==0))
 100   2          { 
 101   3            shizhong_xianshi();   
 102   3          }
 103   2          else if((wen_xian==0)&&(shi_xian==0)&&(ting_xian==1))
 104   2          {
 105   3            tingzhi_xianshi();    
 106   3          }
 107   2      
 108   2          if(s4==0)
 109   2          {
 110   3            //L_ED(1,1);
 111   3            if(jiechu_flag==1)
 112   3              L_ED(0xfa);
 113   3            else L_ED(0xfe);
 114   3            chuangshu();  
 115   3          }
 116   2          else 
C51 COMPILER V9.54   MAIN                                                                  12/27/2017 19:52:22 PAGE 3   

 117   2          {
 118   3            if(jiechu_flag==1)
 119   3              L_ED(0xf9);
 120   3            else L_ED(0xfd);
 121   3            //led(1,0);
 122   3            //led(2,1);
 123   3            jilu();
 124   3          }
 125   2      //    display1(yi,er);
 126   2      //    display2(san,si);
 127   2      //    display3(wu,liu);
 128   2      //    display4(qi,ba);
 129   2      //    Display(8);
 130   2        }
 131   1      }
 132          void jilu()
 133          {
 134   1        
 135   1        uchar r_tem,r_shidu,r_xiaoshi,r_fenzhong,r_miaozhong,r_jctime;
 136   1        if((jiechu_flag==1)&&(num==0))
 137   1        {
 138   2          num=1;
 139   2          iicwrite(ADD,tem);Delay2ms();ADD++;
 140   2          iicwrite(ADD,shidu);Delay2ms();ADD++;
 141   2          iicwrite(ADD,shijian[2]);Delay2ms();ADD++;
 142   2          iicwrite(ADD,shijian[1]);Delay2ms();ADD++;
 143   2          iicwrite(ADD,shijian[0]);Delay2ms();ADD++;
 144   2      
 145   2        }
 146   1        else if((num==1)&&(jiechu_flag==0))
 147   1        {
 148   2          num=0;
 149   2          iicwrite(ADD,jc_time);Delay2ms();ADD++;
 150   2          if(ADD==0x1e) ADD=0x00; //计算得最后的存储位置为0x1d 再加1位0x1e
 151   2        }
 152   1        //if((shuju[0]=='A')&&(shuju[1]=='A')&&(shuju[2]=='A')&&(shuju[3]=='S')&&(shuju[4]=='S')&&(shuju[5]=='S')
             -)
 153   1        if(yanzheng==1)  //发送一段 然后停下 再次输入再次发送
 154   1        {
 155   2          shuju[0]='0'; //将接受数组破坏使之不再满足yanzheng=1条件 直到下次发送AAASSS
 156   2          yanzheng=0;
 157   2          for(WADD=0,i=0;i<5;i++)
 158   2          {
 159   3            r_tem=iicread(WADD);Delay2ms();WADD++;
 160   3            r_shidu=iicread(WADD);Delay2ms();WADD++;
 161   3            r_xiaoshi=iicread(WADD);Delay2ms();WADD++;
 162   3            r_fenzhong=iicread(WADD);Delay2ms();WADD++;
 163   3            r_miaozhong=iicread(WADD);Delay2ms();WADD++;
 164   3            r_jctime=iicread(WADD);Delay2ms();WADD++;
 165   3            sprintf(a,"{%bd-%bd%%}{%bd-%bd-%bd}{%bd}%c",r_tem,r_shidu,r_xiaoshi,r_fenzhong,r_miaozhong,r_jctime,'\n
             -');
 166   3            sendstring(a);  
 167   3          }
 168   2      
 169   2          
 170   2        }       
 171   1      }
 172          void chuangshu()
 173          {
 174   1        if((shuju[0]=='A')&&(shuju[1]=='A')&&(shuju[2]=='A')&&(shuju[3]=='S')&&(shuju[4]=='S')&&(shuju[5]=='S'))
 175   1        {
 176   2          if(fasong_flag==1)
C51 COMPILER V9.54   MAIN                                                                  12/27/2017 19:52:22 PAGE 4   

 177   2          {
 178   3            fasong_flag=0;
 179   3            sprintf(a,"{%bd-%bd%%}{%bd-%bd-%bd}{%bd}%c",tem,shidu,shijian[2],shijian[1],shijian[0],jiechu_flag,'\n'
             -);
 180   3            sendstring(a);
 181   3          
 182   3          }
 183   2        } 
 184   1      }
 185          void sendstring(uchar *p)
 186          {
 187   1        while(*p)
 188   1        {
 189   2          SBUF=*p;
 190   2          p++;
 191   2          while(!TI){};
 192   2          TI=0;
 193   2      //      display1(yi,er);
 194   2      //    display2(san,si);
 195   2      //    display3(wu,liu);
 196   2      //    display4(qi,ba);
 197   2        }   
 198   1      
 199   1      }
 200          
 201          
 202          void UART() interrupt 4
 203          {
 204   1        if(RI)
 205   1        {
 206   2          shuju[n]=SBUF;
 207   2          n++;
 208   2          RI=0;
 209   2          if(n>=6) n=0;
 210   2          if(s4==1)  //要使先发送一段 停下 再判断再发必须写入这里
 211   2          {
 212   3            if((shuju[0]=='A')&&(shuju[1]=='A')&&(shuju[2]=='A')&&(shuju[3]=='S')&&(shuju[4]=='S')&&(shuju[5]=='S')
             -)
 213   3              yanzheng=1;
 214   3          } 
 215   2        }
 216   1        
 217   1      }
 218          void jisuan()
 219          {
 220   1      //  uint ori_time,fin_time;
 221   1        if((light_strength<6)&&(light_state==0)&&(last_light<6))
 222   1        {
 223   2          light_state=1;
 224   2          //led(3,1);
 225   2          jiechu_flag=1;
 226   2          ori_time=shijian[0];
 227   2        }
 228   1        else if((light_strength>=6)&&(light_state==1)&&(last_light>=6))
 229   1        {
 230   2          light_state=0;
 231   2          //led(3,0);
 232   2          jiechu_flag=0;
 233   2          fin_time=shijian[0];
 234   2          if(fin_time>=ori_time)
 235   2            jc_time=fin_time-ori_time;  
 236   2          else
C51 COMPILER V9.54   MAIN                                                                  12/27/2017 19:52:22 PAGE 5   

 237   2            jc_time=60+fin_time-ori_time;
 238   2        }
 239   1      }
 240          void tingzhi_xianshi()
 241          {
 242   1      
 243   1        dsbuff[0]=11;dsbuff[1]=11;dsbuff[2]=11;dsbuff[3]=10;dsbuff[4]=jc_time/1000;
 244   1        dsbuff[5]=jc_time%1000/100;dsbuff[6]=jc_time%100/10;dsbuff[7]=jc_time%10; 
 245   1      //  yi=11;er=11;san=11;si=10;wu=jc_time/1000;
 246   1      //  liu=jc_time%1000/100;qi=jc_time%100/10;ba=jc_time%10;   
 247   1      //    
 248   1      }
 249          void shizhong_xianshi()
 250          {
 251   1        dsbuff[0]=shijian[2]/10;dsbuff[1]=shijian[2]%10;dsbuff[3]=shijian[1]/10;
 252   1        dsbuff[4]=shijian[1]%10;dsbuff[6]=shijian[0]/10;dsbuff[7]=shijian[0]%10;
 253   1      //  yi=shijian[2]/10;er=shijian[2]%10;si=shijian[1]/10;
 254   1      //  wu=shijian[1]%10;qi=shijian[0]/10;ba=shijian[0]%10;   
 255   1      }
 256          void wendu_xianshi()
 257          {
 258   1      //    if(ad_flag==1)
 259   1      //    {
 260   1      //      shidu=adread(0x03);
 261   1      //      shidu=adread(0x03);
 262   1      //      ad_flag=0;
 263   1      //    }
 264   1          dsbuff[0]=tem/10;dsbuff[1]=tem%10;dsbuff[2]=12;dsbuff[3]=11;dsbuff[4]=11;
 265   1          dsbuff[5]=11;dsbuff[6]=shidu/10;dsbuff[7]=shidu%10; 
 266   1      //    yi=tem/10;er=tem%10;san=12;si=11;wu=11;
 267   1      //    liu=11;qi=shidu/10;ba=shidu%10; 
 268   1      }
 269          void time_0() interrupt 1
 270          {
 271   1        static uchar s_liang=0;
 272   1        display();
 273   1        if(++fasong_count==500)
 274   1        {
 275   2          fasong_count=0;
 276   2          fasong_flag=1;
 277   2        }
 278   1        if(++ad_count==200)
 279   1        {
 280   2          ad_count=0;
 281   2          ad_flag=1;
 282   2        }
 283   1        if(++ad_count_2==100)
 284   1        {
 285   2          ad_count_2=0;
 286   2          ad_flag_2=1;
 287   2        }
 288   1        if(shi_xian==1)
 289   1        {
 290   2          if(++shi_count==500)
 291   2          {
 292   3            shi_count=0;
 293   3            if(s_liang==0)
 294   3            {
 295   4              s_liang=1;
 296   4              dsbuff[2]=10;
 297   4              dsbuff[5]=10;
 298   4      //        san=10;
C51 COMPILER V9.54   MAIN                                                                  12/27/2017 19:52:22 PAGE 6   

 299   4      //        liu=10;
 300   4            }
 301   3            else 
 302   3            {
 303   4              s_liang=0;
 304   4              dsbuff[2]=11;
 305   4              dsbuff[5]=11;
 306   4      //        san=11;
 307   4      //        liu=11;
 308   4            }
 309   3          }
 310   2        }
 311   1      }
 312          void display()
 313          {
 314   1        P2=(P2&0x1f)|0xe0;
 315   1        P0=0xff;
 316   1        P2=P2&0x1f;
 317   1      
 318   1        P2=(P2&0x1f)|0xc0;
 319   1        P0=1<<discount;
 320   1        P2=P2&0x1f;
 321   1      
 322   1        P2=(P2&0x1f)|0xe0;
 323   1        P0=tab[dsbuff[discount]];
 324   1        P2=P2&0x1f;
 325   1      
 326   1        if(++discount == 8)
 327   1        {
 328   2          discount=0;
 329   2        }
 330   1      }
 331          void keyscan()
 332          {
 333   1        if(P33==0)
 334   1        {
 335   2          Delay5ms();
 336   2          if(P33==0)
 337   2          {
 338   3            if(s4==0) {s4=1;i=0;shuju[0]='S';WADD=0x00;} //每切换一次记得把接收shuju重新赋值一下 好判断下一个AAASSS
 339   3            else {s4=0;shuju[0]='S';}
 340   3          }
 341   2          while(!P33);
 342   2        }
 343   1          
 344   1        else if(P32==0)
 345   1        {
 346   2          Delay5ms();
 347   2          if(P32==0)
 348   2          {
 349   3            s5++;
 350   3      
 351   3          }
 352   2          while(!P32);
 353   2        }
 354   1        else if(P31==0)
 355   1        {
 356   2          Delay5ms();
 357   2          if(P31==0)
 358   2          {
 359   3            s6=1;
 360   3          }
C51 COMPILER V9.54   MAIN                                                                  12/27/2017 19:52:22 PAGE 7   

 361   2          while(!P31);
 362   2        }
 363   1        else if(P30==0)
 364   1        {
 365   2          Delay5ms();
 366   2          if(P30==0)
 367   2          {
 368   3            s7=1;
 369   3          }
 370   2          while(!P30);
 371   2        }
 372   1      }
 373          //void led(uchar lednum,uchar demand)
 374          //{
 375          //  uchar i;
 376          //  lednum--;
 377          //  i=led_status&(0x01<<lednum);
 378          //  if((i==0)&&(demand==1))
 379          //  {
 380          //    EA=0;
 381          //    P2=P2&0x1f;
 382          //    P2=(P2&0x1f)|0x80;
 383          //    P0=lednum;
 384          //    P2=P2&0x1f;
 385          //    led_status=0x01<<lednum;
 386          //    EA=1;
 387          //  }
 388          //  else if((i>0)&&(demand==0))
 389          //  {
 390          //    EA=0;
 391          //    P2=P2&0x1f;
 392          //    P2=(P2&0x1f)|0x80;
 393          //    P0=0xff;
 394          //    P2=P2&0x1f;
 395          //    led_status=0;
 396          //    EA=1; 
 397          //  }
 398          //}
 399          void L_ED(uchar liang)
 400          {
 401   1        P2=P2&0x1f;
 402   1        P2=(P2&0x1f)|0x80;
 403   1        P0=liang;
 404   1        P2=P2&0x1f; 
 405   1      }
 406          
 407          void led(uchar lednum,uchar demand)
 408          {
 409   1        uchar i;
 410   1        lednum--;
 411   1        i=led_status&(0x01<<lednum);
 412   1        if((i==0)&&(demand==1))
 413   1        {
 414   2          EA=0;
 415   2          P2=P2&0x1f;
 416   2          P2=(P2&0x1f)|0x80;
 417   2          P0&=~(0x01<<lednum);
 418   2          P2=P2&0x1f;
 419   2          led_status=0x01<<lednum;
 420   2          EA=1;
 421   2        }
 422   1        else if((i>0)&&(demand==0))
C51 COMPILER V9.54   MAIN                                                                  12/27/2017 19:52:22 PAGE 8   

 423   1        {
 424   2          EA=0;
 425   2          P2=P2&0x1f;
 426   2          P2=(P2&0x1f)|0x80;
 427   2          P0=0xff;
 428   2          P2=P2&0x1f;
 429   2          led_status=0;
 430   2          EA=1; 
 431   2        }
 432   1      }
 433          //void Timer0Init(void)   //2毫秒@11.0592MHz
 434          //{
 435          //  AUXR |= 0x80;   //定时器时钟1T模式
 436          //  TMOD &= 0xF0;   //设置定时器模式
 437          //  TL0 = 0x9A;   //设置定时初值
 438          //  TH0 = 0xA9;   //设置定时初值
 439          //  TF0 = 0;    //清除TF0标志
 440          //  TR0 = 1;    //定时器0开始计时
 441          //}
 442          void Timer0Init(void)   //2毫秒@12.000MHz
 443          {
 444   1        AUXR |= 0x80;   //定时器时钟1T模式
 445   1        TMOD &= 0xF0;   //设置定时器模式
 446   1        TL0 = 0x40;   //设置定时初值
 447   1        TH0 = 0xA2;   //设置定时初值
 448   1        TF0 = 0;    //清除TF0标志
 449   1        TR0 = 1;    //定时器0开始计时
 450   1      }
 451          
 452          
 453          //void UartInit(void)   //1200bps@11.0592MHz
 454          //{
 455          //  SCON = 0x50;    //8位数据,可变波特率
 456          //  AUXR |= 0x40;   //定时器1时钟为Fosc,即1T
 457          //  AUXR &= 0xFE;   //串口1选择定时器1为波特率发生器
 458          //  TMOD &= 0x0F;   //设定定时器1为16位自动重装方式
 459          //  TL1 = 0x00;   //设定定时初值
 460          //  TH1 = 0xF7;   //设定定时初值
 461          //  ET1 = 0;    //禁止定时器1中断
 462          //  TR1 = 1;    //启动定时器1
 463          //}
 464           void UartInit(void)    //1200bps@12.000MHz
 465          {
 466   1        SCON = 0x50;    //8位数据,可变波特率
 467   1        AUXR |= 0x40;   //定时器1时钟为Fosc,即1T
 468   1        AUXR &= 0xFE;   //串口1选择定时器1为波特率发生器
 469   1        TMOD &= 0x0F;   //设定定时器1为16位自动重装方式
 470   1        TL1 = 0x3C;   //设定定时初值
 471   1        TH1 = 0xF6;   //设定定时初值
 472   1        ET1 = 0;    //禁止定时器1中断
 473   1        TR1 = 1;    //启动定时器1
 474   1      }
 475          
 476          
 477          //void display1(uchar yi,uchar er)
 478          //{
 479          //    P2=0XC0;//打开位选573   U8
 480          //    P0=0X01;//选择第一个数码管
 481          //    P2=0XFF;//打开段选573   U7
 482          //    P0=tab[yi];
 483          //    Delay1ms();
 484          //    
C51 COMPILER V9.54   MAIN                                                                  12/27/2017 19:52:22 PAGE 9   

 485          //    P2=0XC0;//打开位选573   U8
 486          //    P0=0X02;//选择第二个数码管
 487          //    P2=0XFF;//打开段选573   U7
 488          //    P0=tab[er];
 489          //    Delay1ms();
 490          //} 
 491          
 492          //void display2(uchar san,uchar si)
 493          //{
 494          //    P2=0XC0;//打开位选573   U8
 495          //    P0=0X04;//选择第三个数码管
 496          //    P2=0XFF;//打开段选573   U7
 497          //    P0=tab[san];
 498          //      Delay1ms();
 499          //    
 500          //    P2=0XC0;//打开位选573   U8
 501          //    P0=0X08;//选择第四个数码管
 502          //    P2=0XFF;//打开段选573   U7
 503          //    P0=tab[si];
 504          //      Delay1ms();
 505          //}
 506          
 507          //void display3(uchar wu,uchar liu)
 508          //{
 509          //    P2=0XC0;//打开位选573   U8
 510          //    P0=0X10;//选择第一个数码管
 511          //    P2=0XFF;//打开段选573   U7
 512          //    P0=tab[wu];
 513          //      Delay1ms();
 514          //    
 515          //    P2=0XC0;//打开位选573   U8
 516          //    P0=0X20;//选择第一个数码管
 517          //    P2=0XFF;//打开段选573   U7
 518          //    P0=tab[liu];
 519          //      Delay1ms();
 520          //}
 521          
 522          //void display4(uchar qi,uchar ba)
 523          //{
 524          //    P2=0XC0;//打开位选573   U8
 525          //    P0=0X40;//选择第一个数码管
 526          //    P2=0XFF;//打开段选573   U7
 527          //    P0=tab[qi];
 528          //      Delay1ms();
 529          //    
 530          //    P2=0XC0;//打开位选573   U8
 531          //    P0=0X80;//选择第一个数码管
 532          //    P2=0XFF;//打开段选573   U7
 533          //    P0=tab[ba];
 534          //      Delay1ms();
 535          
 536          //    P2=0XC0;//打开位选573   U8
 537          //    P0=0X80;//选择第一个数码管
 538          //    P2=0XFF;//打开段选573   U7
 539          //    P0=0xff;
 540          //      Delay1ms();
 541          //}
 542          //void DSLED(uint date,uint wei,uchar dp)
 543          //{
 544          //  P2 &= 0x1f;
 545          //  P2 |= 0xe0;        //关闭所有数码管y7c  段选
 546          //  P0 = 0xff;  
C51 COMPILER V9.54   MAIN                                                                  12/27/2017 19:52:22 PAGE 10  

 547          //  
 548          //  P2 &= 0x1f; //将P2口高三位清除以便使用译码器                                    
 549          //  P0 = ledwdata[wei];  //选通第几个数码管显示
 550          //  P2 |= 0xc0;  //位选
 551          //         
 552          //  if(wei == dp)   //当显示的位数与dp相同时对应的位显示小数点
 553          //  {
 554          //    P2 &= 0x1f; //将P2口高三位清除以便使用译码器 关闭y4c,y5c,y6c,y7c  
 555          //    P0 = tab[date]&0x7f;   //段码  &0x7f在对应的位显示小数点
 556          //    P2 |= 0xe0;  //段选
 557          //    P2 &= 0x1f; //关闭y4c,y5c,y6c,y7c
 558          //  }
 559          //  else      //当显示的位数与dp不同时不显示小数点
 560          //  {
 561          //    P2 &= 0x1f; //将P2口高三位清除以便使用译码器 关闭y4c,y5c,y6c,y7c  
 562          //    P0 = tab[date];   //段码 
 563          //    P2 |= 0xe0;  //段选
 564          //    P2 &= 0x1f; //关闭y4c,y5c,y6c,y7c
 565          //  }
 566          //}
 567          //
 568          ////dp 取值0~7 小数点位置
 569          //void Display(uchar dp)
 570          //{
 571          //  uchar dspcom = 0; //显示位置 第几个数码管显示
 572          //
 573          //  for(dspcom=0;dspcom<8;dspcom++)
 574          //  {
 575          //    DSLED(dsbuff[dspcom],dspcom,dp);   //数码管驱动函数
 576          //    Delay1ms();
 577          //  }
 578          //}


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1412    ----
   CONSTANT SIZE    =     53    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =     29    ----
   DATA SIZE        =     52       6
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
