C51 COMPILER V9.54   MAIN                                                                  12/26/2017 09:46:55 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\keil   55\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\ma
                    -in.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          
   2          #include <STC15F2K60S2.h>
   3          #include <delay.h>
   4          #include <iic.h>
   5          #include <ds1302.h>
   6          
   7          #define TX P10
   8          #define RX P11
   9          #define uchar unsigned char
  10          #define uint unsigned int
  11          #define somenop1 {_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();}
  12          
  13          uchar code tab[13]={0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90,0xbf,0xff,0x00};
  14          uchar dsbuff[8]={11,11,11,11,11,11,11,11};
  15          uint distance;
  16          uchar discount;
  17          uchar open=0;
  18          uchar s4,s5,s6,s7;
  19          uchar shi_shan,fen_shan,miao_shan;
  20          uchar ss1,ss2,ss3,ss4;
  21          uchar ceju_flag;
  22          uchar s_liang,f_liang,m_liang;
  23          uchar dis_flag,baocun_flag,beep_distance;
  24          uchar led_shan_flag,l_liang;
  25          uchar flag_1=1;
  26          
  27          void Timer0Init();
  28          void Timer1Init();
  29          void display();
  30          void keyscan();
  31          void ledctrl(uchar lednum,uchar demand);
  32          void fengming(uchar demand);
  33          void shizhong_shan();
  34          void shizhong_handle();
  35          void distance_handle();
  36          uint dis_get();
  37          void sendwave();
  38          
  39          void allinit()
  40          {
  41   1        P2=0x80;P0=0xff;
  42   1        P2=0xa0;P0=0x00;
  43   1        P2=0xc0;P0=0xff;
  44   1        P2=0xe0;P0=0xff;
  45   1      }
  46          
  47          void main()
  48          {   
  49   1        Timer0Init(); 
  50   1        Timer1Init();
  51   1        beep_distance=iicread(0x00);
  52   1        dswrite(); 
  53   1        while(1)
  54   1        {
C51 COMPILER V9.54   MAIN                                                                  12/26/2017 09:46:55 PAGE 2   

  55   2          if(open==0)//初始化亮一秒钟
  56   2          {
  57   3            ledctrl(1,1);
  58   3            dsbuff[0]=12;
  59   3            dsbuff[1]=12;
  60   3            dsbuff[2]=12;
  61   3            dsbuff[3]=12;
  62   3            dsbuff[4]=12;
  63   3            dsbuff[5]=12;
  64   3            dsbuff[6]=12;
  65   3            dsbuff[7]=12;
  66   3            fengming(1);    
  67   3          }
  68   2          else if(open==1)//一秒后进入主显示界面
  69   2          {
  70   3            if(flag_1==1)//只进入一次初始化
  71   3            {
  72   4              allinit();
  73   4              flag_1=0;
  74   4            } 
  75   3            keyscan();//按键扫描
  76   3            dsread();//读取ds1302的时间
  77   3            if(s7==0)//s7没有按下时显示时钟
  78   3            {
  79   4              shizhong_handle();
  80   4            }
  81   3            if(s7==1)//s7按下时显示距离
  82   3            {
  83   4              distance_handle();
  84   4            }
  85   3          }
  86   2        }     
  87   1      }
  88          
  89          void distance_handle()
  90          {
  91   1        switch(s6)//在距离显示界面下，s6没有按下，则显示距离，s6按下显示设置报警距离界面
  92   1        {
  93   2          case 1:dis_flag=1;break;
  94   2          case 2:dis_flag=0;baocun_flag=1;s6=0;break;
  95   2        }
  96   1        if(ceju_flag==1)//定时扫描测距函数
  97   1        {
  98   2          distance=dis_get();
  99   2          if(distance<beep_distance)//判断现在的距离是否小于报警距离
 100   2          {
 101   3            fengming(1);
 102   3            led_shan_flag=0;
 103   3          }
 104   2          else if((distance<1.2*beep_distance)&&(distance>=beep_distance))//判断现在距离是否大于报警距离，且小于报
             -警距离的1.2倍
 105   2          {
 106   3            fengming(0);
 107   3            led_shan_flag=1;
 108   3          }
 109   2          else if(distance>=1.2*beep_distance)   //注意条件大于报警距离的1.2倍
 110   2          {
 111   3            fengming(0);
 112   3            ledctrl(1,0);
 113   3            led_shan_flag=0;
 114   3          }
 115   2          ceju_flag=0;
C51 COMPILER V9.54   MAIN                                                                  12/26/2017 09:46:55 PAGE 3   

 116   2        }
 117   1        if(s6==0)//s6没有按下显示距离
 118   1        {
 119   2          dsbuff[0]=11;
 120   2          dsbuff[1]=11;
 121   2          dsbuff[2]=11;
 122   2          dsbuff[3]=11;
 123   2          dsbuff[4]=11;
 124   2          dsbuff[5]=distance/100;
 125   2          dsbuff[6]=distance%100/10;
 126   2          dsbuff[7]=distance%10;
 127   2        }
 128   1        else //s6按下显示设置报警距离
 129   1        {
 130   2          if(dis_flag==1)
 131   2          {
 132   3            dsbuff[0]=11;
 133   3            dsbuff[1]=11;
 134   3            dsbuff[2]=11;
 135   3            dsbuff[3]=11;
 136   3            dsbuff[4]=11;
 137   3            dsbuff[5]=11;
 138   3            dsbuff[6]=beep_distance/10;
 139   3            dsbuff[7]=beep_distance%10;
 140   3            if(s5==1)//在设置报警距离下按下s5加报警距离
 141   3            {
 142   4              s5=0;
 143   4              beep_distance+=1;
 144   4            }
 145   3            else if(s4==1)//按下s4减报警距离
 146   3            {
 147   4              s4=0;
 148   4              beep_distance-=1;
 149   4            } 
 150   3          }
 151   2        } 
 152   1        if(baocun_flag==1)//如果报警，把设置的报警距离保存在eeprom
 153   1        {
 154   2          baocun_flag=0;
 155   2          iicwrite(0x00,beep_distance);
 156   2        }
 157   1      }
 158          
 159          uint dis_get()
 160          {
 161   1        uint dis;
 162   1        sendwave();//发送一个40KHZ的方波
 163   1        TR1=1;
 164   1        while((RX)&&(TF1==0));
 165   1        TR1=0;
 166   1        if(TF1)
 167   1        {
 168   2          TF1=0;
 169   2          dis=999;
 170   2        }
 171   1        else 
 172   1        {
 173   2          dis=(TH1<<8)|(TL1);
 174   2          dis=dis*0.017; 
 175   2        }
 176   1        TH1=TL1=0;//记得要软件清零
 177   1        return dis;
C51 COMPILER V9.54   MAIN                                                                  12/26/2017 09:46:55 PAGE 4   

 178   1      }
 179          
 180          void sendwave()
 181          {
 182   1        TX=1;
 183   1        somenop1;somenop1;somenop1;somenop1;somenop1;
 184   1        somenop1;somenop1;somenop1;somenop1;somenop1;
 185   1        TX=0;                   
 186   1      }
 187          
 188          void time_0() interrupt 1
 189          {
 190   1        display();
 191   1        if(ss1<500)
 192   1        ++ss1;
 193   1        if(ss1==500)//开机显示用的定时
 194   1        {
 195   2          open=1;
 196   2          ss1=501;
 197   2        }
 198   1        shizhong_shan();//时钟闪烁函数定时扫描
 199   1        if(++ss3==200)//测距标志位
 200   1        { 
 201   2          ss3=0;
 202   2          ceju_flag=1;
 203   2        }
 204   1        if(led_shan_flag==1)//LED闪烁处理
 205   1        {
 206   2          if(++ss4==200)
 207   2          {
 208   3            ss4=0;
 209   3            if(l_liang==0)
 210   3            {
 211   4              l_liang=1;
 212   4              ledctrl(1,1);
 213   4            }
 214   3            else 
 215   3            {
 216   4              l_liang=0;
 217   4              ledctrl(1,0);
 218   4            }
 219   3          }
 220   2        }
 221   1        
 222   1      }
 223          
 224          
 225          void keyscan()
 226          {
 227   1        if(P33==0)
 228   1        {
 229   2          Delay5ms();
 230   2          if(P33==0)
 231   2          {
 232   3            if(s6>0)
 233   3            s4=1;
 234   3          }
 235   2          while(!P33);
 236   2        }
 237   1        else if(P32==0)
 238   1        {
 239   2          Delay5ms();
C51 COMPILER V9.54   MAIN                                                                  12/26/2017 09:46:55 PAGE 5   

 240   2          if(P32==0)
 241   2          {
 242   3            if(s6>0)
 243   3            s5=1;
 244   3          }
 245   2          while(!P32);
 246   2        }
 247   1        else if(P31==0)
 248   1        {
 249   2          Delay5ms();
 250   2          if(P31==0)
 251   2          {
 252   3            s6++;
 253   3          }
 254   2          while(!P31);
 255   2        }
 256   1        else if(P30==0)
 257   1        {
 258   2          Delay5ms();
 259   2          if(P30==0)
 260   2          {
 261   3            if(s7==0) 
 262   3            {
 263   4              s7=1;
 264   4              s6=0;
 265   4            }
 266   3            else 
 267   3            {
 268   4              s7=0;
 269   4              s6=0;
 270   4            }
 271   3          }
 272   2          while(!P30);
 273   2        }
 274   1      }
 275          
 276          void display()
 277          {
 278   1        P2=(P2&0x1f)|0xe0;
 279   1        P0=0xff;
 280   1        P2=P2&0x1f;
 281   1      
 282   1        P2=(P2&0x1f)|0xc0;
 283   1        P0=1<<discount;
 284   1        P2=P2&0x1f;
 285   1      
 286   1        P2=(P2&0x1f)|0xe0;
 287   1        P0=tab[dsbuff[discount]];
 288   1        P2=P2&0x1f;
 289   1      
 290   1        if(++discount==8) discount=0;
 291   1      }
 292          
 293          void Timer0Init(void)   //2毫秒@11.0592MHz
 294          {
 295   1        AUXR |= 0x80;         //定时器时钟1T模式
 296   1        TMOD &= 0xF0;         //设置定时器模式
 297   1        TL0 = 0x9A;           //设置定时初值
 298   1        TH0 = 0xA9;           //设置定时初值
 299   1        TF0 = 0;              //清除TF0标志
 300   1        TR0 = 1;              //定时器0开始计时
 301   1      }
C51 COMPILER V9.54   MAIN                                                                  12/26/2017 09:46:55 PAGE 6   

 302          
 303          void ledctrl(uchar lednum,uchar demand)
 304          {
 305   1        uchar i;
 306   1        static uchar led_state=0;
 307   1        lednum--;
 308   1        i=led_state&(0x01<<lednum);
 309   1        if((i==0)&&(demand==1))
 310   1        {
 311   2          EA=0;
 312   2          led_state=0x01<<lednum;
 313   2          P2=(P2&0x1f)|0x80;
 314   2          P0=~(0x01<<lednum);
 315   2          P2=P2&0x1f;
 316   2          EA=1;
 317   2        }
 318   1        else if((i>0)&&(demand==0))
 319   1        {
 320   2          EA=0;
 321   2          led_state=0;
 322   2          P2=(P2&0x1f)|0x80;
 323   2          P0=0xff;
 324   2          P2=P2&0x1f;
 325   2          EA=1;
 326   2        } 
 327   1      }
 328          
 329          void fengming(uchar demand)
 330          {
 331   1        static xiang_state=0; 
 332   1        if((demand==1)&&(xiang_state==0))
 333   1        {
 334   2          P0=0x00;
 335   2          EA=0;
 336   2          P2=(P2&0x1f)|0xa0;
 337   2          P0=0x40;
 338   2          P2=P2&0x1f;
 339   2          xiang_state=1;
 340   2          EA=1; 
 341   2        }
 342   1        else if((demand==0)&&(xiang_state==1))
 343   1        {
 344   2          xiang_state=0;
 345   2          P2=(P2&0x1f)|0xa0;
 346   2          P0=0x00;
 347   2          P2=P2&0x1f;
 348   2        }
 349   1      }
 350          void shizhong_shan()
 351          {
 352   1        if(shi_shan==1)//时闪烁标志位
 353   1        {
 354   2          if(++ss2==200)
 355   2          {
 356   3            ss2=0;
 357   3            if(s_liang==1)
 358   3            {
 359   4              s_liang=0;
 360   4              dsbuff[0]=shijian[2]/10;
 361   4              dsbuff[1]=shijian[2]%10;
 362   4              dsbuff[2]=10;
 363   4              dsbuff[3]=shijian[1]/10;
C51 COMPILER V9.54   MAIN                                                                  12/26/2017 09:46:55 PAGE 7   

 364   4              dsbuff[4]=shijian[1]%10;
 365   4              dsbuff[5]=10;
 366   4              dsbuff[6]=shijian[0]/10;
 367   4              dsbuff[7]=shijian[0]%10;
 368   4            }
 369   3            else 
 370   3            {
 371   4              s_liang=1;
 372   4              dsbuff[0]=11;
 373   4              dsbuff[1]=11;
 374   4              dsbuff[2]=10;
 375   4              dsbuff[3]=shijian[1]/10;
 376   4              dsbuff[4]=shijian[1]%10;
 377   4              dsbuff[5]=10;
 378   4              dsbuff[6]=shijian[0]/10;
 379   4              dsbuff[7]=shijian[0]%10;
 380   4            }
 381   3          }
 382   2        }
 383   1        else if(fen_shan==1)
 384   1        {
 385   2          if(++ss2==200)
 386   2          {
 387   3            ss2=0;
 388   3            if(f_liang==1)
 389   3            {
 390   4              f_liang=0;
 391   4              dsbuff[0]=shijian[2]/10;
 392   4              dsbuff[1]=shijian[2]%10;
 393   4              dsbuff[2]=10;
 394   4              dsbuff[3]=shijian[1]/10;
 395   4              dsbuff[4]=shijian[1]%10;
 396   4              dsbuff[5]=10;
 397   4              dsbuff[6]=shijian[0]/10;
 398   4              dsbuff[7]=shijian[0]%10;
 399   4            }
 400   3            else 
 401   3            {
 402   4              f_liang=1;
 403   4              dsbuff[0]=shijian[2]/10;
 404   4              dsbuff[1]=shijian[2]%10;
 405   4              dsbuff[2]=10;
 406   4              dsbuff[3]=11;
 407   4              dsbuff[4]=11;
 408   4              dsbuff[5]=10;
 409   4              dsbuff[6]=shijian[0]/10;
 410   4              dsbuff[7]=shijian[0]%10;
 411   4            }
 412   3          }
 413   2        }
 414   1        else if(miao_shan==1)
 415   1        {
 416   2          if(++ss2==200)
 417   2          {
 418   3            ss2=0;
 419   3            if(m_liang==1)
 420   3            {
 421   4              m_liang=0;
 422   4              dsbuff[0]=shijian[2]/10;
 423   4              dsbuff[1]=shijian[2]%10;
 424   4              dsbuff[2]=10;
 425   4              dsbuff[3]=shijian[1]/10;
C51 COMPILER V9.54   MAIN                                                                  12/26/2017 09:46:55 PAGE 8   

 426   4              dsbuff[4]=shijian[1]%10;
 427   4              dsbuff[5]=10;
 428   4              dsbuff[6]=shijian[0]/10;
 429   4              dsbuff[7]=shijian[0]%10;
 430   4            }
 431   3            else 
 432   3            {
 433   4              m_liang=1;
 434   4              dsbuff[0]=shijian[2]/10;
 435   4              dsbuff[1]=shijian[2]%10;
 436   4              dsbuff[2]=10;
 437   4              dsbuff[3]=shijian[1]/10;
 438   4              dsbuff[4]=shijian[1]%10;
 439   4              dsbuff[5]=10;
 440   4              dsbuff[6]=11;
 441   4              dsbuff[7]=11;
 442   4            }
 443   3          }
 444   2        }
 445   1      }
 446           
 447          void shizhong_handle()
 448          {
 449   1        switch(s6)
 450   1        {
 451   2          case 1:shi_shan=1;fen_shan=0;miao_shan=0;break;
 452   2          case 2:shi_shan=0;fen_shan=1;miao_shan=0;break;
 453   2          case 3:shi_shan=0;fen_shan=0;miao_shan=1;break;
 454   2          case 4:s6=0;break;
 455   2        }
 456   1        if(s6==0)
 457   1        {
 458   2          dsbuff[0]=shijian[2]/10;
 459   2          dsbuff[1]=shijian[2]%10;
 460   2          dsbuff[2]=10;
 461   2          dsbuff[3]=shijian[1]/10;
 462   2          dsbuff[4]=shijian[1]%10;
 463   2          dsbuff[5]=10;
 464   2          dsbuff[6]=shijian[0]/10;
 465   2          dsbuff[7]=shijian[0]%10;
 466   2        }
 467   1        if(shi_shan==1)
 468   1        {
 469   2          if(s5==1)
 470   2          {
 471   3            s5=0;
 472   3            if(shijian[2]<=22)
 473   3            shijian[2]=shijian[2]+1;
 474   3            dswrite();
 475   3          }
 476   2          else if(s4==1)
 477   2          {
 478   3            s4=0;
 479   3            if(shijian[2]>0)
 480   3            shijian[2]=shijian[2]-1;
 481   3            dswrite();
 482   3          } 
 483   2        }
 484   1        else if(fen_shan==1)    //考虑循环时分秒显示 边界判断
 485   1        {
 486   2          if(s5==1)
 487   2          {
C51 COMPILER V9.54   MAIN                                                                  12/26/2017 09:46:55 PAGE 9   

 488   3            s5=0;
 489   3            if(shijian[1]<=58)
 490   3            shijian[1]=shijian[1]+1;
 491   3            dswrite();
 492   3          }
 493   2          else if(s4==1)
 494   2          {
 495   3            s4=0;
 496   3            if(shijian[1]>0)
 497   3            shijian[1]=shijian[1]-1;
 498   3            dswrite();
 499   3          } 
 500   2        }
 501   1        else if(miao_shan==1)
 502   1        {
 503   2          if(s5==1)
 504   2          {
 505   3            s5=0;
 506   3            if(shijian[0]<=58)
 507   3            shijian[0]=shijian[0]+1;
 508   3            dswrite();
 509   3          }
 510   2          else if(s4==1)
 511   2          {
 512   3            s4=0;
 513   3            if(shijian[0]>0)
 514   3            shijian[0]=shijian[0]-1;
 515   3            dswrite();
 516   3          } 
 517   2        } 
 518   1      }
 519          
 520          void Timer1Init(void)   //0微秒@11.0592MHz
 521          {
 522   1        AUXR &= 0xBF;         //定时器时钟12T模式
 523   1        TMOD &= 0x0F;         //设置定时器模式
 524   1        TL1 = 0x00;           //设置定时初值
 525   1        TH1 = 0x00;           //设置定时初值
 526   1        TF1 = 0;              //清除TF1标志
 527   1        TR1 = 0;              //定时器1开始计时
 528   1        EA=1;
 529   1        ET0=1;  
 530   1      }
 531            


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1676    ----
   CONSTANT SIZE    =     13    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     36       2
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
