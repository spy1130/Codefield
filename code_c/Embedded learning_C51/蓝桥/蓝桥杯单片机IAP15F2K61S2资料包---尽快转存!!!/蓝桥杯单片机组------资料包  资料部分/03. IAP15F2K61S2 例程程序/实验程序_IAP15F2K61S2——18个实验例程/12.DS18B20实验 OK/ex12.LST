C51 COMPILER V9.52.0.0   EX12                                                              11/16/2019 14:32:48 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE EX12
OBJECT MODULE PLACED IN ex12.OBJ
COMPILER INVOKED BY: C:\Keil_51\C51\BIN\C51.EXE ex12.c BROWSE DEFINE(STC12) DEBUG OBJECTEXTEND

line level    source

   1          /*******************************************************************************  
   2          * 文件名称：DS18B20温度传感器实验
   3          * 实验目的：1.掌握单总线通讯基本特点和工作时序
   4          *           2.掌握51单片机模拟单总线时序的程序设计方法
   5          *           3.掌握DS18B20温度传感器的操作方法
   6          * 程序说明：1.通过数码管显示实时温度数据
   7          *           2.DS18B20数据线引脚DQ与单片机P1.4引脚连接
   8          *           3.测量精度为1摄氏度
   9          *           4.数码管驱动函数采用IO方式编写，将跳线J13调整为IO模式
  10          * 硬件说明：IAP15F2K61S2@11.0592MHz
  11          * 日期版本：2012-9-5/V1.0a 
  12          *******************************************************************************/
  13          
  14          #include "reg52.h"  //定义51单片机特殊功能寄存器
  15          #include "absacc.h"
  16          #include "ds18b20.h"
  17          
  18          sfr AUXR = 0x8E; 
  19          
  20          unsigned char dspbuf[8] = {10,10,10,10,10,10,10,10};//显示缓冲区
  21          unsigned char dspcom = 0;
  22          unsigned char intr;
  23          bit temper_flag = 0;//温度读取标志
  24          code unsigned char tab[] = {0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90,
  25                                      0xff};
  26          
  27          void display(void);
  28          
  29          void cls_buzz()
  30          {
  31   1              P2 = ((P2&0x1f)|0xA0); 
  32   1              P0 = 0x00;
  33   1              P2 &= 0x1f;
  34   1      }
  35          void cls_led()
  36          {
  37   1              P2 = ((P2&0x1f)|0x80); 
  38   1              P0 = 0xFF;
  39   1              P2 &= 0x1f;
  40   1      }
  41          
  42          //主函数
  43          void main(void)
  44          { 
  45   1          unsigned char temperature;
  46   1              
  47   1              cls_buzz();
  48   1              cls_led();
  49   1          
  50   1              AUXR |= 0x80;
  51   1              TMOD &= 0xF0;
  52   1              TL0 = 0xCD;     
  53   1              TH0 = 0xD4;     
  54   1              TF0 = 0;        
  55   1              TR0 = 1;
C51 COMPILER V9.52.0.0   EX12                                                              11/16/2019 14:32:48 PAGE 2   

  56   1              ET0 = 1;
  57   1              EA = 1;
  58   1              
  59   1          while(1)
  60   1          {
  61   2              if(temper_flag)
  62   2                      {
  63   3                              temper_flag = 0;
  64   3                              temperature = temget();  //读温度         
  65   3              }
  66   2                      
  67   2                      //显示数据更新    
  68   2                      (temperature>=10)?(dspbuf[6] = temperature/10):(dspbuf[6]=10);       
  69   2                      dspbuf[7] = temperature%10; 
  70   2          }
  71   1      }
  72          
  73          //定时器中断服务函数
  74          void isr_timer_0(void)  interrupt 1  //默认中断优先级 1
  75          {
  76   1          display();
  77   1              if(++intr == 100)  //1ms执行一次
  78   1              {
  79   2              intr = 0;
  80   2                      temper_flag = 1;  //100ms温度读取标志位置1
  81   2          }
  82   1      }
  83          
  84          //显示函数
  85          void display(void)
  86          {   
  87   1              P2 = ((P2&0x1f)|0xE0); 
  88   1              P0 = 0xff;
  89   1              P2 &= 0x1f;
  90   1      
  91   1              P0 = 1<<dspcom; 
  92   1              P2 = ((P2&0x1f)|0xC0); 
  93   1              P2 &= 0x1f;
  94   1              
  95   1              P0 = tab[dspbuf[dspcom]];       
  96   1          P2 = ((P2&0x1f)|0xE0); 
  97   1              P2 &= 0x1f;
  98   1              
  99   1          if(++dspcom == 8){
 100   2              dspcom = 0;
 101   2          }    
 102   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    242    ----
   CONSTANT SIZE    =     11    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     10       1
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
