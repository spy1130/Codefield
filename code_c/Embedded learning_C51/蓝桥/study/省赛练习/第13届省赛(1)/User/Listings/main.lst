C51 COMPILER V9.60.7.0   MAIN                                                              04/04/2024 16:06:14 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: E:\Applications\Keil_5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\Driver) DEBUG OBJE
                    -CTEXTEND PRINT(.\Listings\main.lst) OBJECT(.\Objects\main.obj)

line level    source

   1          //先Seg减速，顺带定时器别忘了ET0=1,EA=1;Seg扫描，led+扫描，Key减速+三行消抖，主程序
   2          #include <STC15F2K60S2.H>
   3          #include <init.h>
   4          #include <Led.h>
   5          #include <Key.h>
   6          #include <Seg.h>
   7          #include "ds1302.h"
   8          #include "onewire.h"
   9          
  10          unsigned char Seg_Slow_Down;
  11          unsigned char Seg_Buf[8]={10,10,10,10,10,10,10,10};
  12          unsigned char Seg_Point[8]={0,0,0,0,0,0,0,0};
  13          unsigned char Seg_Pos;
  14          unsigned char Seg_Mode_Disp;//0-温度显示；1-时间显示；2-参数设置
  15          unsigned char ucLed[8]={0,0,0,0,0,0,0,0};
  16          unsigned char ucRtc[3]={0x07,0x59,0x20};//时间储存
  17          unsigned char Key_Val,Key_Old,Key_Down,Key_Up;
  18          unsigned char Key_Slow_Down;
  19          float temperature;//真实温度
  20          unsigned char temp_ctrl=23;//温度阈值
  21          unsigned char temp_disp=23;//温度阈值
  22          bit Relay_Buf;//继电器控制位
  23          bit Ctrl_Mode ;//0-温度控制；1-时间控制
  24          bit Seg_Time_Mode;//时间显示模式
  25          bit Alarm_Flag;//整点标志位
  26          bit Led_Flash;//闪烁判断
  27          unsigned int Timer_5000ms;//延迟变量
  28          unsigned char Timer_100ms;//闪烁延时变量
  29          void Key_Proc()
  30          {
  31   1              if(Key_Slow_Down)return;
  32   1              Key_Slow_Down =1;
  33   1              //重点记
  34   1              Key_Val=Key_Read();
  35   1              Key_Down=Key_Val &(Key_Old^Key_Val);
  36   1              Key_Up=~Key_Val &(Key_Old^Key_Val);
  37   1              Key_Old =Key_Val;
  38   1      
  39   1              switch(Key_Down)
  40   1              {       case 12://切换模式
  41   2                      if(++Seg_Mode_Disp==3)
  42   2                              Seg_Mode_Disp=0;
  43   2                      if(Seg_Mode_Disp==0)
  44   2                               temp_disp=temp_ctrl;
  45   2                      if(Seg_Mode_Disp==1)
  46   2                              temp_ctrl=temp_disp;
  47   2                      break;
  48   2                      case 13://控制模式切换
  49   2                              //初始化所有
  50   2                              ucLed[2]=0;
  51   2                              Relay(0);
  52   2                              
  53   2                              Ctrl_Mode^=1;
  54   2                      break;
C51 COMPILER V9.60.7.0   MAIN                                                              04/04/2024 16:06:14 PAGE 2   

  55   2                      case 16:
  56   2                              if(Seg_Mode_Disp==2){
  57   3                              if(++temp_ctrl==100)
  58   3                                      temp_ctrl=99;}
  59   2                      case 17:
  60   2                              if(Seg_Mode_Disp==2){
  61   3                              if(--temp_ctrl==9)
  62   3                                      temp_ctrl=10;}
  63   2                              else if(Seg_Mode_Disp==1)
  64   2                              {
  65   3                                      Seg_Time_Mode=1;
  66   3                              }
  67   2                      break;  
  68   2              }
  69   1              if(Key_Up==17 && Seg_Time_Mode==1)
  70   1              {
  71   2                      Seg_Time_Mode=0;
  72   2              }
  73   1      }
  74          
  75          
  76          void Seg_Proc()
  77          {       //等于0时进入
  78   1              if(Seg_Slow_Down) return;
  79   1              Seg_Slow_Down =1;
  80   1              temperature=rd_temperature();
  81   1              Read_Rtc(ucRtc);
  82   1              Seg_Buf[0]=11;
  83   1              Seg_Buf[1]=Seg_Mode_Disp+1;
  84   1              if(Seg_Mode_Disp==0)//温度
  85   1              {
  86   2                      Seg_Buf[5]=(unsigned char)temperature/10%10;
  87   2                      Seg_Buf[6]=(unsigned char)temperature%10;
  88   2                      Seg_Buf[7]=(unsigned int)(temperature*10)%10;
  89   2                      Seg_Point[6]=1;
  90   2              }
  91   1              else if(Seg_Mode_Disp==1)//时间
  92   1              {       Seg_Point[6]=0;
  93   2                      if(Seg_Time_Mode==0){
  94   3                      Seg_Buf[3]=ucRtc[0]/16;
  95   3                      Seg_Buf[4]=ucRtc[0]%16;
  96   3                      Seg_Buf[5]=12;
  97   3                      Seg_Buf[6]=ucRtc[1]/16;
  98   3                      Seg_Buf[7]=ucRtc[1]%16;
  99   3                      }
 100   2                      else
 101   2                      {
 102   3                      Seg_Buf[3]=ucRtc[1]/16;
 103   3                      Seg_Buf[4]=ucRtc[1]%16;
 104   3                      Seg_Buf[5]=12;
 105   3                      Seg_Buf[6]=ucRtc[2]/16;
 106   3                      Seg_Buf[7]=ucRtc[2]%16;
 107   3                      }
 108   2              }
 109   1              else if(Seg_Mode_Disp==2)//参数
 110   1              {
 111   2                      Seg_Buf[6]=temp_disp/10;
 112   2                      Seg_Buf[7]=temp_disp%10;
 113   2                      Seg_Point[6]=0;
 114   2              }
 115   1      }
 116          
C51 COMPILER V9.60.7.0   MAIN                                                              04/04/2024 16:06:14 PAGE 3   

 117          void Led_Proc()
 118          {
 119   1              if(ucRtc[1]==0x00 && ucRtc[2]==0x00 && Alarm_Flag==0)
 120   1                      Alarm_Flag=1;
 121   1              
 122   1              ucLed[0]=Alarm_Flag;
 123   1              ucLed[1]=~Ctrl_Mode;
 124   1              ucLed[2]=Relay_Buf?Led_Flash:0;
 125   1              if(Ctrl_Mode==0)
 126   1              {
 127   2                      Relay_Buf=(temperature>temp_ctrl);
 128   2              }
 129   1              else
 130   1              {
 131   2                      Relay_Buf=Alarm_Flag;
 132   2              }
 133   1      }
 134          
 135          void Timer0_Init(void)          //1毫秒@12.000MHz
 136          {
 137   1              AUXR &= 0x7F;                   //定时器时钟12T模式
 138   1              TMOD &= 0xF0;                   //设置定时器模式
 139   1              TL0 = 0x18;                             //设置定时初始值
 140   1              TH0 = 0xFC;                             //设置定时初始值
 141   1              TF0 = 0;                                //清除TF0标志
 142   1              TR0 = 1;                                //定时器0开始计时
 143   1              ET0=1;
 144   1              EA=1;
 145   1      }
 146          /* Timer0 interrupt routine */
 147          void tm0_isr() interrupt 1
 148          {       if(++Key_Slow_Down == 10) Key_Slow_Down = 0;//键盘减速专用
 149   1          if(++Seg_Slow_Down==500) Seg_Slow_Down=0;//数码管减速专用
 150   1              if(++Seg_Pos==8)Seg_Pos=0;
 151   1              Seg_Disp(Seg_Pos,Seg_Buf[Seg_Pos],Seg_Point[Seg_Pos]);
 152   1              Led_Disp(Seg_Pos,ucLed[Seg_Pos]);
 153   1              Relay(Relay_Buf);
 154   1              
 155   1              if(Alarm_Flag)Timer_5000ms++;
 156   1              else Timer_5000ms=0;
 157   1              if(Timer_5000ms==5000)
 158   1              {
 159   2                      Timer_5000ms=0;
 160   2                      Alarm_Flag=0;
 161   2              }
 162   1              if(Relay_Buf)Timer_100ms++;
 163   1              else Timer_100ms=0;
 164   1              if(Timer_100ms==100)
 165   1              {
 166   2                      Timer_100ms=0;
 167   2                      Led_Flash^=1;
 168   2              }
 169   1      }
 170          
 171          void Delay750ms(void)   //@12.000MHz
 172          {
 173   1              unsigned char data i, j, k;
 174   1      
 175   1              i = 35;
 176   1              j = 51;
 177   1              k = 182;
 178   1              do
C51 COMPILER V9.60.7.0   MAIN                                                              04/04/2024 16:06:14 PAGE 4   

 179   1              {
 180   2                      do
 181   2                      {
 182   3                              while (--k);
 183   3                      } while (--j);
 184   2              } while (--i);
 185   1      }
 186          
 187          
 188          void main()
 189          {       rd_temperature();
 190   1              Delay750ms();
 191   1              Set_Rtc(ucRtc);
 192   1              System_Init();
 193   1              Timer0_Init();
 194   1              while(1)
 195   1              {
 196   2                      Seg_Proc();
 197   2                      Key_Proc();
 198   2                      Led_Proc();
 199   2                      
 200   2              }
 201   1              
 202   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    681    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     44    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      5    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
