C51 COMPILER V9.60.7.0   MAIN                                                              04/11/2024 23:35:54 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: E:\Applications\Keil_5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\Driver) DEBUG OBJE
                    -CTEXTEND PRINT(.\Listings\main.lst) OBJECT(.\Objects\main.obj)

line level    source

   1          //先Seg减速，顺带定时器别忘了ET0=1,EA=1;Seg扫描，led+扫描，Key减速+三行消抖，主程序
   2          #include <STC15F2K60S2.H>
   3          #include <init.h>
   4          #include <Led.h>
   5          #include <Key.h>
   6          #include <Seg.h>
   7          #include "iic.h"
   8          #include "ds1302.h"
   9          
  10          unsigned char Seg_Slow_Down;
  11          unsigned char Seg_Buf[8]={10,10,10,10,10,10,10,10};
  12          unsigned char Seg_Point[8]={0,0,0,0,0,0,0,0};
  13          unsigned char Seg_Pos;
  14          unsigned char Seg_Disp_Mode;//0-时间界面，1-输入界面，2-记录界面
  15          
  16          unsigned char ucRtc[3]={0x23,0x09,0x59};
  17          unsigned char ucRtc_Finish_Disp[3];
  18          
  19          unsigned char ucLed[8]={0,0,0,0,0,0,0,0};
  20          
  21          unsigned char Key_Val,Key_Old,Key_Down,Key_Up;
  22          unsigned char Key_Slow_Down;
  23          unsigned char Input_Data[4];//输入数组
  24          unsigned char Input_Data_Index;//索引值
  25          unsigned int new_value;
  26          unsigned int old_value;
  27          unsigned char EEPROM_string_new[4];
  28          unsigned char EEPROM_string_old[4];
  29          bit data_up_flag; // 数据上升标志
  30          void Key_Proc()
  31          {       unsigned char i;
  32   1              if(Key_Slow_Down)return;
  33   1              Key_Slow_Down =1;
  34   1              //重点记
  35   1              Key_Val=Key_Read();
  36   1              Key_Down=Key_Val &(Key_Old^Key_Val);
  37   1              Key_Up=~Key_Val &(Key_Old^Key_Val);
  38   1              Key_Old =Key_Val;
  39   1              
  40   1              switch(Key_Down)
  41   1              {
  42   2                      case 4:
  43   2                              
  44   2                              if(Seg_Disp_Mode==1)
  45   2                              {
  46   3                                              
  47   3                                              new_value = Input_Data[1] * 1000 + Input_Data[2] * 100 + Input_Data[3] * 10 + Input_Data[4];
  48   3                                              EEPROM_string_new[0] = ucRtc_Finish_Disp[0] / 16 * 10 + ucRtc_Finish_Disp[0] % 16;
  49   3                                              EEPROM_string_new[1] = ucRtc_Finish_Disp[1] / 16 * 10 + ucRtc_Finish_Disp[1] % 16;
  50   3                                              EEPROM_string_new[2] = new_value & 0xff00;
  51   3                                              EEPROM_string_new[3] = new_value & 0x00ff;
  52   3                                              EEPROM_Write(EEPROM_string_new, 0, 4);//4个字节
  53   3                                              data_up_flag = (new_value > old_value);
  54   3                                              old_value = new_value;
C51 COMPILER V9.60.7.0   MAIN                                                              04/11/2024 23:35:54 PAGE 2   

  55   3                              }
  56   2                              if(++Seg_Disp_Mode==3)Seg_Disp_Mode=0;
  57   2                              for (i = 0; i < 4; i++)
  58   2                                      Input_Data[i] = 10; // 直接对应灭，每次进行界面切换的时候就清空一下数组
  59   2                              Input_Data_Index= 0;       // 输入数据索引重置
  60   2                      break;
  61   2                      if(Seg_Disp_Mode==1){
  62   3                              // 输入第一位数据了
  63   3                              if(Input_Data_Index==1)
  64   3                                      Read_Rtc(ucRtc_Finish_Disp);
  65   3                              
  66   3                              case 5:                         
  67   3                                      for(i=0;i<4;i++)
  68   3                                              Input_Data[i]=10;
  69   3                                              Input_Data_Index=0;
  70   3                              break;
  71   3                              if(Input_Data_Index<4)
  72   3                              {
  73   4                              case 6:
  74   4                                      if(Input_Data_Index!=4)
  75   4                                              Input_Data[Input_Data_Index]=0;
  76   4                                      if(++Input_Data_Index==5)
  77   4                                              Input_Data_Index=4;
  78   4                              break;
  79   4                              case 10:
  80   4                                      if(Input_Data_Index!=4)
  81   4                                              Input_Data[Input_Data_Index]=1;
  82   4                                      if(++Input_Data_Index==5)
  83   4                                              Input_Data_Index=4;
  84   4                              break;
  85   4                              case 14:
  86   4                                      if(Input_Data_Index!=4)
  87   4                                              Input_Data[Input_Data_Index]=2;
  88   4                                      if(++Input_Data_Index==5)
  89   4                                              Input_Data_Index=4;
  90   4                              break;
  91   4                              case 18:
  92   4                                      if(Input_Data_Index!=4)
  93   4                                              Input_Data[Input_Data_Index]=3;
  94   4                                      if(++Input_Data_Index==5)
  95   4                                              Input_Data_Index=4;
  96   4                              break;
  97   4                              case 9:
  98   4                                      if(Input_Data_Index!=4)
  99   4                                              Input_Data[Input_Data_Index]=4;
 100   4                                      if(++Input_Data_Index==5)
 101   4                                              Input_Data_Index=4;
 102   4                              break;
 103   4                              case 13:
 104   4                                      if(Input_Data_Index!=4)
 105   4                                              Input_Data[Input_Data_Index]=5;
 106   4                                      if(++Input_Data_Index==5)
 107   4                                              Input_Data_Index=4;
 108   4                              break;
 109   4                              case 17:
 110   4                                      if(Input_Data_Index!=4)
 111   4                                              Input_Data[Input_Data_Index]=6;
 112   4                                      if(++Input_Data_Index==5)
 113   4                                              Input_Data_Index=4;
 114   4                              break;
 115   4                              case 8:
 116   4                                      if(Input_Data_Index!=4)
C51 COMPILER V9.60.7.0   MAIN                                                              04/11/2024 23:35:54 PAGE 3   

 117   4                                              Input_Data[Input_Data_Index]=7;
 118   4                                      if(++Input_Data_Index==5)
 119   4                                              Input_Data_Index=4;
 120   4                              break;
 121   4                              case 12:
 122   4                                      if(Input_Data_Index!=4)
 123   4                                              Input_Data[Input_Data_Index]=8;
 124   4                                      if(++Input_Data_Index==5)
 125   4                                              Input_Data_Index=4;
 126   4                              break;
 127   4                              case 16:
 128   4                                      if(Input_Data_Index!=4)
 129   4                                              Input_Data[Input_Data_Index]=9;
 130   4                                      if(++Input_Data_Index==5)
 131   4                                              Input_Data_Index=4;
 132   4                              break;
 133   4                              }
 134   3                      }
 135   2              }
 136   1              
 137   1      }
 138          
 139          
 140          void Seg_Proc()
 141          {       unsigned char i;
 142   1              //等于0时进入
 143   1              if(Seg_Slow_Down) return;
 144   1              Seg_Slow_Down =1;
 145   1              switch(Seg_Disp_Mode)
 146   1              {
 147   2                      case 0://时间界面
 148   2                              Read_Rtc(ucRtc);
 149   2                              Seg_Buf[0]=ucRtc[0]/16;
 150   2                              Seg_Buf[1]=ucRtc[0]%16;
 151   2                              Seg_Buf[3]=ucRtc[1]/16;
 152   2                              Seg_Buf[4]=ucRtc[1]%16;
 153   2                              Seg_Buf[6]=ucRtc[2]/16;
 154   2                              Seg_Buf[7]=ucRtc[2]%16;
 155   2                              Seg_Buf[5]=Seg_Buf[2]=11;//-
 156   2                      break;
 157   2                      case 1://输入界面
 158   2                              
 159   2                              Seg_Buf[0]=12;//C
 160   2                              Seg_Buf[1]=Seg_Buf[3]=Seg_Buf[2]=10;
 161   2                      if (Input_Data_Index == 0)
 162   2              {       //基本必进
 163   3                  Seg_Buf[4] = Seg_Buf[5] = Seg_Buf[6] = Seg_Buf[7] = 10;
 164   3              }
 165   2              else
 166   2              {       //Input_Data_Index ==1后
 167   3                              //右对齐
 168   3                              for(i=0;i<Input_Data_Index;i++)
 169   3                                      Seg_Buf[7-i]=Input_Data[Input_Data_Index-i-1];//这里Input_Data_Index =1，所以要减1对齐索引，从最高位减
             -起
 170   3                              //其他关掉
 171   3                              for(;i<4;i++)
 172   3                                      Seg_Buf[7-i]=10;        
 173   3                      }       
 174   2                      break;
 175   2                      case 2://记录界面
 176   2                              Seg_Buf[0]=13;//E
 177   2                              Seg_Buf[3]=ucRtc_Finish_Disp[0]/16;
C51 COMPILER V9.60.7.0   MAIN                                                              04/11/2024 23:35:54 PAGE 4   

 178   2                              Seg_Buf[4]=ucRtc_Finish_Disp[0]%16;
 179   2                              Seg_Buf[5]=11;//-
 180   2                              Seg_Buf[6]=ucRtc_Finish_Disp[1]/16;
 181   2                              Seg_Buf[7]=ucRtc_Finish_Disp[1]%16;     
 182   2                      break;
 183   2              }
 184   1      
 185   1      }
 186          
 187          void Led_Proc()
 188          {
 189   1              ucLed[0] = (Seg_Disp_Mode == 0);
 190   1          ucLed[1] = (Seg_Disp_Mode == 1);
 191   1          ucLed[2] = (Seg_Disp_Mode == 2);
 192   1      
 193   1          ucLed[3] = data_up_flag;
 194   1      }
 195          
 196          void Timer0_Init(void)          //1毫秒@12.000MHz
 197          {
 198   1              AUXR &= 0x7F;                   //定时器时钟12T模式
 199   1              TMOD &= 0xF0;                   //设置定时器模式
 200   1              TL0 = 0x18;                             //设置定时初始值
 201   1              TH0 = 0xFC;                             //设置定时初始值
 202   1              TF0 = 0;                                //清除TF0标志
 203   1              TR0 = 1;                                //定时器0开始计时
 204   1              ET0=1;
 205   1              EA=1;
 206   1      }
 207          
 208          /* Timer0 interrupt routine */
 209          void tm0_isr() interrupt 1
 210          {       if(++Key_Slow_Down ==10) Key_Slow_Down = 0;//键盘减速专用
 211   1          if(++Seg_Slow_Down==500) Seg_Slow_Down=0;//数码管减速专用
 212   1              if(++Seg_Pos==8)Seg_Pos=0;
 213   1              Seg_Disp(Seg_Pos,Seg_Buf[Seg_Pos],Seg_Point[Seg_Pos]);
 214   1              Led_Disp(Seg_Pos,ucLed[Seg_Pos]);
 215   1      }
 216          
 217          
 218          
 219          void main()
 220          {       
 221   1              System_Init();
 222   1              Timer0_Init();
 223   1              Set_Rtc(ucRtc);
 224   1              EEPROM_Read(EEPROM_string_old, 0, 4);//写入到old里
 225   1          old_value = EEPROM_string_old[2] << 8 | EEPROM_string_old[3];
 226   1              while(1)
 227   1              {
 228   2                      Seg_Proc();
 229   2                      Key_Proc();
 230   2                      Led_Proc();
 231   2              }
 232   1              
 233   1      }
*** WARNING C294 IN LINE 61 OF main.c: unreachable code
*** WARNING C294 IN LINE 71 OF main.c: unreachable code


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    974    ----
C51 COMPILER V9.60.7.0   MAIN                                                              04/11/2024 23:35:54 PAGE 5   

   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     55       1
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
