C51 COMPILER V9.60.7.0   IIC                                                               04/11/2024 23:35:54 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE IIC
OBJECT MODULE PLACED IN .\Objects\iic.obj
COMPILER INVOKED BY: E:\Applications\Keil_5\C51\BIN\C51.EXE ..\Driver\iic.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\Driver) D
                    -EBUG OBJECTEXTEND PRINT(.\Listings\iic.lst) OBJECT(.\Objects\iic.obj)

line level    source

   1          /*      #   I2C代码片段说明
   2                  1.      本文件夹中提供的驱动代码供参赛选手完成程序设计参考。
   3                  2.      参赛选手可以自行编写相关代码或以该代码为基础，根据所选单片机类型、
             -行速度和试题
   4                          中对单片机时钟频率的要求，进行代码调试和修改。
   5          */
   6          /*
   7          看原理图设引脚
   8          
   9          AD转换：
  10          先开启发送;PCF地址-0x90确定写模式;再等待应答
  11          输入要转换的通道（0x41-通道1,AIN1，光敏电阻；0x43-通道3,AIN3，滑动变阻器）;等
             -应答。
  12          再开启信号;0x91-选择PCF8591芯片;确定读的模式;再等待应答
  13          接收数据传给临时变量;选择不应答1;停止发送。
  14          
  15          DA转换:
  16          先开启发送;PCF地址-0x90确定写模式;再等待应答
  17          使能DA转换（随便写通道编号，不影响，主要的功能是使能DA）;等待应答.
  18          将待转换的数据发送出去;等待应答;停止发送
  19          
  20          写EEPROM函数:
  21          入口参数：需要写入的字符串，写入的地址(务必为8的倍数)，写入数量
  22          开启信号;0xA0选择EEPROM芯片，确定写的模式;等待EEPROM反馈
  23          写入要存储的数据地址;等待EEPROM反馈
  24          while循环让（写入数量--）作为判断条件
  25          {
  26                  将要（*写入的信息++）写入；等待EEPROM反馈；延时200   
  27          }
  28          停止发送
  29          
  30          读EEPROM函数:
  31          入口参数：读到的数据需要存储的字符串，读取的地址(务必为8的倍数)，读取的u
             -8数量
  32          开启信号;0xA0选择EEPROM芯片，确定写的模式;等待EEPROM反馈
  33          写入要存储的数据地址;等待EEPROM反馈
  34          开启信号;0xA1选择EEPROM芯片，确定读的模式;等待EEPROM反馈
  35          while循环让（写入数量--）作为判断条件
  36          {
  37          将要*读取的信息++=接受信息；if（读取的数量不为0）发送应答，否则不应答；
  38          }
  39          停止发送
  40          */
  41          #include <STC15F2K60S2.H>
  42          #include "iic.h"
  43          #include "intrins.h"
  44          #define DELAY_TIME      10
  45          sbit scl=P2^0; /* 时钟线 */
  46          sbit sda=P2^1;/* 数据线 */
  47          
  48          //
  49          static void I2C_Delay(unsigned char n)
  50          {
  51   1          do
C51 COMPILER V9.60.7.0   IIC                                                               04/11/2024 23:35:54 PAGE 2   

  52   1          {
  53   2              _nop_();_nop_();_nop_();_nop_();_nop_();
  54   2              _nop_();_nop_();_nop_();_nop_();_nop_();
  55   2              _nop_();_nop_();_nop_();_nop_();_nop_();                
  56   2          }
  57   1          while(n--);         
  58   1      }
  59          
  60          //总线启动条件
  61          void I2CStart(void)
  62          {
  63   1          sda = 1;
  64   1          scl = 1;
  65   1              I2C_Delay(DELAY_TIME);
  66   1          sda = 0;
  67   1              I2C_Delay(DELAY_TIME);
  68   1          scl = 0;    
  69   1      }
  70          
  71          //总线停止条件
  72          void I2CStop(void)
  73          {
  74   1          sda = 0;
  75   1          scl = 1;
  76   1              I2C_Delay(DELAY_TIME);
  77   1          sda = 1;
  78   1              I2C_Delay(DELAY_TIME);
  79   1      }
  80          
  81          //通过I2C总线发送数据
  82          void I2CSendByte(unsigned char byt)
  83          {
  84   1          unsigned char i;
  85   1              
  86   1          for(i=0; i<8; i++){
  87   2              scl = 0;
  88   2                      I2C_Delay(DELAY_TIME);
  89   2              if(byt & 0x80){
  90   3                  sda = 1;
  91   3              }
  92   2              else{
  93   3                  sda = 0;
  94   3              }
  95   2                      I2C_Delay(DELAY_TIME);
  96   2              scl = 1;
  97   2              byt <<= 1;
  98   2                      I2C_Delay(DELAY_TIME);
  99   2          }
 100   1              
 101   1          scl = 0;  
 102   1      }
 103          
 104          //从I2C总线上接收数据
 105          unsigned char I2CReceiveByte(void)
 106          {
 107   1              unsigned char da;
 108   1              unsigned char i;
 109   1              for(i=0;i<8;i++){   
 110   2                      scl = 1;
 111   2                      I2C_Delay(DELAY_TIME);
 112   2                      da <<= 1;
 113   2                      if(sda) 
C51 COMPILER V9.60.7.0   IIC                                                               04/11/2024 23:35:54 PAGE 3   

 114   2                              da |= 0x01;
 115   2                      scl = 0;
 116   2                      I2C_Delay(DELAY_TIME);
 117   2              }
 118   1              return da;    
 119   1      }
 120          
 121          //等待应答
 122          unsigned char I2CWaitAck(void)
 123          {
 124   1              unsigned char ackbit;
 125   1              
 126   1          scl = 1;
 127   1              I2C_Delay(DELAY_TIME);
 128   1          ackbit = sda; 
 129   1          scl = 0;
 130   1              I2C_Delay(DELAY_TIME);
 131   1              
 132   1              return ackbit;
 133   1      }
 134          
 135          //发送应答
 136          void I2CSendAck(unsigned char ackbit)
 137          {
 138   1          scl = 0;
 139   1          sda = ackbit; // 0：应答，1：非应答
 140   1              I2C_Delay(DELAY_TIME);
 141   1          scl = 1;
 142   1              I2C_Delay(DELAY_TIME);
 143   1          scl = 0; 
 144   1              sda = 1;
 145   1              I2C_Delay(DELAY_TIME);
 146   1      }
 147          //函数名：ADC转换函数
 148          //入口参数：要进行转换的通道控制位
 149          //返回值：ADC转换的数值
 150          //函数功能：对指定的通道进行ADC转换，函数返回转换的数值
 151          unsigned char Ad_Read(unsigned char addr)
 152          {       
 153   1              unsigned char temp;
 154   1              I2CStart();//发送开启信号
 155   1              I2CSendByte(0x90);//选择PCF8591芯片，确定写的模式
 156   1              I2CWaitAck();//等待PCF8591反馈
 157   1              
 158   1              I2CSendByte(addr);//确定要转换的通道（顺便，使能DA转换）
 159   1              I2CWaitAck();//等待PCF8591反馈
 160   1              
 161   1              I2CStart();//发送开启信号
 162   1              I2CSendByte(0x91);//选择PCF8591芯片，确定读的模式
 163   1              I2CWaitAck();//等待PCF8591反馈
 164   1              
 165   1              temp=I2CReceiveByte();//接收数据
 166   1              I2CSendAck(1);//选择不应答
 167   1              I2CStop();//停止发送
 168   1              
 169   1              return temp;
 170   1      }
 171          
 172          
 173          
 174          //函数名：DAC转换函数
 175          //入口参数：要进行转换的数值
C51 COMPILER V9.60.7.0   IIC                                                               04/11/2024 23:35:54 PAGE 4   

 176          //返回值：无
 177          //函数功能：对入口参数要转换的DA数据进行转换
 178          void Pcf8591_Dac(unsigned char trans_dat)
 179          {
 180   1              I2CStart();//发送开启信号
 181   1              I2CSendByte(0x90);//选择PCF8591芯片，确定写的模式
 182   1              I2CWaitAck();//等待PCF8591反馈
 183   1              
 184   1              I2CSendByte(0x41);//使能DA转换（随便写通道编号，不影响，主要的功能是使能DA）
 185   1              I2CWaitAck();//等待PCF8591反馈
 186   1              
 187   1              I2CSendByte(trans_dat);//将待转换的数据发送出去
 188   1              I2CWaitAck();//等待PCF8591反馈
 189   1              I2CStop();//停止发送        
 190   1      }
 191          
 192          //函数名：写EEPROM函数
 193          //入口参数：需要写入的字符串，写入的地址(务必为8的倍数)，写入数量
 194          //返回值：无
 195          //函数功能：向EERPOM的某个地址写入字符串中特定数量的字符。
 196          void EEPROM_Write(unsigned char* EEPROM_String, unsigned char addr, unsigned char num)
 197          {
 198   1              I2CStart();//发送开启信号
 199   1              I2CSendByte(0xA0);//选择EEPROM芯片，确定写的模式
 200   1              I2CWaitAck();//等待EEPROM反馈
 201   1              
 202   1              I2CSendByte(addr);//写入要存储的数据地址
 203   1              I2CWaitAck();//等待EEPROM反馈       
 204   1              
 205   1              while(num--)
 206   1              {
 207   2                      I2CSendByte(*EEPROM_String++);//将要写入的信息写入
 208   2                      I2CWaitAck();//等待EEPROM反馈               
 209   2                      I2C_Delay(200); 
 210   2              }
 211   1              
 212   1              I2CStop();//停止发送        
 213   1      }
 214          
 215          //函数名：读EEPROM函数
 216          //入口参数：读到的数据需要存储的字符串，读取的地址(务必为8的倍数)，读取
             -数量
 217          //返回值：无
 218          //函数功能：读取EERPOM的某个地址中的数据，并存放在字符串数组中。
 219          void EEPROM_Read(unsigned char* EEPROM_String, unsigned char addr, unsigned char num)
 220          {
 221   1              I2CStart();//发送开启信号
 222   1              I2CSendByte(0xA0);//选择EEPROM芯片，确定写的模式
 223   1              I2CWaitAck();//等待EEPROM反馈
 224   1              
 225   1              I2CSendByte(addr);//写入要存储的数据地址
 226   1              I2CWaitAck();//等待EEPROM反馈
 227   1      
 228   1              I2CStart();//发送开启信号
 229   1              I2CSendByte(0xA1);//选择EEPROM芯片，确定读的模式
 230   1              I2CWaitAck();//等待EEPROM反馈       
 231   1      
 232   1              while(num--)
 233   1              {
 234   2                      *EEPROM_String++ = I2CReceiveByte();//将要写入的信息写入
 235   2                      if(num) I2CSendAck(0);//发送应答
 236   2                              else I2CSendAck(1);//不应答
C51 COMPILER V9.60.7.0   IIC                                                               04/11/2024 23:35:54 PAGE 5   

 237   2              }
 238   1      
 239   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    358    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      10
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
