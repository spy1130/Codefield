C51 COMPILER V9.60.7.0   MAIN                                                              03/27/2024 22:23:33 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: E:\Applications\Keil_5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\Driver) DEBUG OBJE
                    -CTEXTEND PRINT(.\Listings\main.lst) OBJECT(.\Objects\main.obj)

line level    source

   1          /* 头文件声明区 */
   2          #include <STC15F2K60S2.H>//单片机寄存器专用头文件
   3          #include <Init.h>//初始化底层驱动专用头文件
   4          #include <Led.h>//Led底层驱动专用头文件
   5          #include <Key.h>//按键底层驱动专用头文件
   6          #include <Seg.h>//数码管底层驱动专用头文件
   7          #include <stdio.h>//标准库底层驱动专用头文件
   8          #include "iic.h"
   9          
  10          /* 变量声明区 */
  11          unsigned char Key_Val,Key_Down,Key_Old,Key_Up;//按键专用变量
  12          unsigned char Key_Slow_Down;//按键减速专用变量
  13          unsigned char Seg_Buf[8] = {10,10,10,10,10,10,10,10};//数码管显示数据存放数组
  14          unsigned char Seg_Point[8] = {0,0,0,0,0,0,0,0};//数码管小数点数据存放数组
  15          unsigned char Seg_Pos;//数码管扫描专用变量
  16          unsigned int Seg_Slow_Down;//数码管减速专用变量
  17          unsigned char ucLed[8] = {0,0,0,0,0,0,0,0};//Led显示数据存放数组
  18          unsigned int T_Disp[4]={400,400,400,400};//流转间隔数据显示数组400~1200ms
  19          unsigned int T_Ctrl[4]={400,400,400,400};//流转间隔数据控制数组400~1200ms(保存运行变量)
  20          unsigned char T_Index;//流转间隔指针-运行模式编号
  21          bit Seg_Disp_Mode;//0-设置，1-亮度显示
  22          unsigned int Ms_Tick;//系统计时变量
  23          bit Start_Flag;//流转启动标志位 0-暂停 1-启动
  24          unsigned char Led_Mode;//系统流转模式变量
  25          unsigned char eeprom_dat[4];//存储变量
  26          unsigned int time_400ms;//数码管闪烁时间位
  27          bit time_flag;//数码管闪烁标志位
  28          unsigned char Seg_Index;//数码管索引值 0-熄灭 1-模式 2-流转间隔
  29          unsigned char Led_Pos;//led索引
  30          unsigned char Led_Level;//Led亮度等级变量
  31          unsigned char Led_Count;//Led亮度计数值
  32          
  33          /* 键盘处理函数 */
  34          void Key_Proc()
  35          {
  36   1              if(Key_Slow_Down) return;
  37   1              Key_Slow_Down = 1;//键盘减速程序
  38   1      
  39   1              Key_Val = Key_Read();//实时读取键码值
  40   1              Key_Down = Key_Val & (Key_Old ^ Key_Val);//捕捉按键下降沿
  41   1              Key_Up = ~Key_Val & (Key_Old ^ Key_Val);//捕捉按键上降沿
  42   1              Key_Old = Key_Val;//辅助扫描变量
  43   1              if(Seg_Index==0)//如果熄灭
  44   1              {
  45   2                      if(Key_Old==4){
  46   3                              Seg_Disp_Mode=1; Seg_Slow_Down=0;}
  47   2                      else
  48   2                      {
  49   3                              Seg_Disp_Mode=0;
  50   3                      }
  51   2              }
  52   1              switch(Key_Down)
  53   1              {       unsigned char i;
  54   2                      case 6:
C51 COMPILER V9.60.7.0   MAIN                                                              03/27/2024 22:23:33 PAGE 2   

  55   2                              if(++Seg_Index==3)Seg_Index =0;
  56   2                      
  57   2                              if(Seg_Index==0)
  58   2                              {       T_Index=0;//复位，不知道该不该有
  59   3                                      for(i=0;i<4;i++){
  60   4                                      T_Ctrl[i]=T_Disp[i];//保存
  61   4                                      eeprom_dat[i]=T_Ctrl[i]/100;//除100后这样就都小于255了
  62   4                                      }
  63   3                                      EEPROM_Write(eeprom_dat,0,4);
  64   3                              }
  65   2                              
  66   2                      break;
  67   2                      case 7://启动按键
  68   2                      Start_Flag ^= 1;
  69   2                      break;
  70   2                      case 5://+
  71   2                              if(Seg_Index==1)
  72   2                              {
  73   3                                      if(++T_Index==4)
  74   3                                      {
  75   4                                              T_Index=0;
  76   4                                      }
  77   3                              }
  78   2                              else if(Seg_Index==2)
  79   2                              {
  80   3                                      T_Disp[T_Index]+=100;
  81   3                                      if(T_Disp[T_Index]>1200)
  82   3                                              T_Disp[T_Index]=1200;
  83   3                              }
  84   2                      break;
  85   2                      case 4:
  86   2                              if(Seg_Index==1)
  87   2                              {
  88   3                                      if(--T_Index==255)
  89   3                                      {
  90   4                                              T_Index=3;
  91   4                                      }
  92   3                              }
  93   2                              else if(Seg_Index==2)
  94   2                              {
  95   3                                      T_Disp[T_Index]-=100;
  96   3                                      if(T_Disp[T_Index]<400)
  97   3                                              T_Disp[T_Index]=400;
  98   3                              }
  99   2                      break;
 100   2              }
 101   1      
 102   1      }
 103          
 104          /* 信息处理函数 */
 105          void Seg_Proc()
 106          {       unsigned char i;
 107   1              if(Seg_Slow_Down) return;
 108   1              Seg_Slow_Down = 1;//数码管减速程序
 109   1              
 110   1              Led_Level=Ad_Read(0x03)/64;//0~255,256个数/64=4,程序是255/4=3。模式为0，1，2，3
 111   1              if(Seg_Disp_Mode==0)//参数设置界面
 112   1              {
 113   2                      Seg_Buf[0]=11;
 114   2                      Seg_Buf[1]=T_Index+1;
 115   2                      Seg_Buf[2]=11;
 116   2                      Seg_Buf[4]=T_Disp[T_Index]/1000%10?T_Disp[T_Index]:10;
C51 COMPILER V9.60.7.0   MAIN                                                              03/27/2024 22:23:33 PAGE 3   

 117   2                      Seg_Buf[5]=T_Disp[T_Index]/100%10;
 118   2                      Seg_Buf[6]=T_Disp[T_Index]/10%10;
 119   2                      Seg_Buf[7]=T_Disp[T_Index]%10;
 120   2                      if(Seg_Index==1)
 121   2                      {
 122   3                              Seg_Buf[0]=Seg_Buf[2]=time_flag?10:11;
 123   3                              Seg_Buf[1]=time_flag?10:T_Index+1;      
 124   3                      }
 125   2                      else if(Seg_Index ==2)
 126   2                      {
 127   3                              Seg_Buf[4]=time_flag?10:T_Disp[T_Index] /1000 % 10;
 128   3                              Seg_Buf[5]=time_flag?10:T_Disp[T_Index]/100%10;
 129   3                              Seg_Buf[6]=time_flag?10:T_Disp[T_Index]/10%10;
 130   3                              Seg_Buf[7]=time_flag?10:T_Disp[T_Index]%10;
 131   3                      }
 132   2                      if(Seg_Buf[4] == 0) Seg_Buf[4] = 10;
 133   2              }
 134   1              else//亮灯等级界面
 135   1              {
 136   2                      for(i=0;i<6;i++)
 137   2                              Seg_Buf[i]=10;
 138   2                              Seg_Buf[6]=11;
 139   2                              Seg_Buf[7]=Led_Level+1;
 140   2              }
 141   1      
 142   1      }
 143          
 144          /* 其他显示函数 */
 145          void Led_Proc()
 146          {       unsigned char i;
 147   1              if(Start_Flag == 1) //系统处于启动状态
 148   1              {
 149   2                      if(Ms_Tick ==T_Ctrl[T_Index]) //系统计时时间达到流转时间间隔
 150   2                      {                         
 151   3                              Ms_Tick = 0;//复位计时 便于下次进入
 152   3                              switch(Led_Mode)
 153   3                              {
 154   4                                      case 0:
 155   4                                              if(++Led_Pos ==8)
 156   4                                              {
 157   5                                                      Led_Pos=7;
 158   5                                                      Led_Mode=1;
 159   5                                              }
 160   4                                      break;
 161   4                                      case 1:
 162   4                                              if(--Led_Pos ==255)
 163   4                                              {       
 164   5                                                      Led_Pos = 7;//模式3起始值
 165   5                                                      Led_Mode=2;
 166   5                                              }
 167   4                                      break;
 168   4                                      case 2://07+9=16+9=25+9=34
 169   4                                              Led_Pos+=9;
 170   4                                              if(Led_Pos >34)
 171   4                                              {
 172   5                                                      Led_Pos =34;
 173   5                                                      Led_Mode=3;
 174   5                                              }
 175   4                                      break;
 176   4                                      case 3:
 177   4                                              Led_Pos-=9;
 178   4                                              if(Led_Pos >200)//07-9=-2对u8来说是255-2=253
C51 COMPILER V9.60.7.0   MAIN                                                              03/27/2024 22:23:33 PAGE 4   

 179   4                                              {
 180   5                                                      Led_Pos =0;
 181   5                                                      Led_Mode=0;
 182   5                                              }
 183   4                                      break;
 184   4                              }
 185   3                      }
 186   2              }
 187   1              if(Led_Mode<2)
 188   1              {
 189   2              for(i=0;i<8;i++)
 190   2              {
 191   3                      ucLed[i]=(i==Led_Pos);//互斥输出
 192   3              }
 193   2              }
 194   1              else
 195   1              {       for(i=0;i<8;i++)
 196   2                      ucLed[i]=((i==(Led_Pos/10))||(i==(Led_Pos%10)));//拆分数07，16.....
 197   2              }
 198   1      }
 199          
 200          
 201          /* 定时器0中断初始化函数 */
 202          void Timer0Init(void)           //1毫秒@12.000MHz
 203          {
 204   1              AUXR &= 0x7F;           //定时器时钟12T模式
 205   1              TMOD &= 0xF0;           //设置定时器模式
 206   1              TL0 = 0x18;             //设置定时初始值
 207   1              TH0 = 0xFC;             //设置定时初始值
 208   1              TF0 = 0;                //清除TF0标志
 209   1              TR0 = 1;                //定时器0开始计时
 210   1              ET0 = 1;    //定时器中断0打开
 211   1              EA = 1;     //总中断打开
 212   1      }
 213          
 214          /* 定时器0中断服务函数 */
 215          void Timer0Server() interrupt 1
 216          {  
 217   1              if(++Key_Slow_Down == 10) Key_Slow_Down = 0;//键盘减速专用
 218   1              if(++Seg_Slow_Down == 500) Seg_Slow_Down = 0;//数码管减速专用
 219   1              if(++Seg_Pos == 8) Seg_Pos = 0;//数码管显示专用
 220   1              if(++Led_Count==12)Led_Count=0;//
 221   1              if(Seg_Index !=0||Seg_Disp_Mode==1)
 222   1              Seg_Disp(Seg_Pos,Seg_Buf[Seg_Pos],Seg_Point[Seg_Pos]);
 223   1              else Seg_Disp(Seg_Pos,10,0);
 224   1              if(Led_Count <=((Led_Level+1)*3))
 225   1                      Led_Disp(Seg_Pos,ucLed[Seg_Pos]);
 226   1              else Led_Disp(Seg_Pos,0);
 227   1              if(++time_400ms==400)
 228   1              {
 229   2                      time_400ms=0;
 230   2                      time_flag ^=1;
 231   2              }
 232   1              if(Start_Flag == 1) //系统启动时开始计时
 233   1                      Ms_Tick++;
 234   1      }
 235          
 236          
 237          
 238          /* Main */
 239          void main()
 240          {       unsigned char i;
C51 COMPILER V9.60.7.0   MAIN                                                              03/27/2024 22:23:33 PAGE 5   

 241   1              System_Init();
 242   1              Timer0Init();
 243   1              EEPROM_Read(eeprom_dat,0,4);
 244   1              for(i=0;i<4;i++)
 245   1              {
 246   2                      T_Disp[i]=T_Ctrl[i]=eeprom_dat[i]*100;//除100后这样就都小于255了
 247   2              }
 248   1              while (1)
 249   1              {
 250   2                      Key_Proc();
 251   2                      Seg_Proc();
 252   2                      Led_Proc();
 253   2                      
 254   2              }
 255   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1181    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     62       1
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      3    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
