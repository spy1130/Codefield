C51 COMPILER V9.54   MAIN                                                                  04/30/2023 12:49:57 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\Driver) DEBUG OBJECTEXTEND PRI
                    -NT(.\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          /* å¤´æ–‡ä»¶å£°æ˜åŒº */
   2          #include <STC15F2K60S2.H>//å•ç‰‡æœºå¯„å­˜å™¨ä¸“ç”¨å¤´æ–‡ä»¶
   3          #include <Init.h>//åˆå§‹åŒ–åº•å±‚é©±åŠ¨ä¸“ç”¨å¤´æ–‡ä»¶
   4          #include <Led.h>//Ledåº•å±‚é©±åŠ¨ä¸“ç”¨å¤´æ–‡ä»¶
   5          #include <Key.h>//æŒ‰é”®åº•å±‚é©±åŠ¨ä¸“ç”¨å¤´æ–‡ä»¶
   6          #include <Seg.h>//æ•°ç ç®¡åº•å±‚é©±åŠ¨ä¸“ç”¨å¤´æ–‡ä»¶
   7          #include <stdio.h>//æ ‡å‡†åº“åº•å±‚é©±åŠ¨ä¸“ç”¨å¤´æ–‡ä»¶
   8          #include "iic.h"//å•æ€»çº¿åº•å±‚é©±åŠ¨ä¸“ç”¨å¤´æ–‡ä»¶
   9          #include <ultrasound.h>//è¶…å£°æ³¢åº•å±‚é©±åŠ¨ä¸“ç”¨å¤´æ–‡ä»¶
  10          
  11          /* å˜é‡å£°æ˜åŒº */
  12          unsigned char Key_Val,Key_Down,Key_Old,Key_Up;//æŒ‰é”®ä¸“ç”¨å˜é‡
  13          unsigned char Key_Slow_Down;//æŒ‰é”®å‡é€Ÿä¸“ç”¨å˜é‡
  14          unsigned char Seg_Buf[8] = {10,10,10,10,10,10,10,10};//æ•°ç ç®¡æ˜¾ç¤ºæ•°æ®å­˜æ”¾æ•°ç»„
  15          unsigned char Seg_Point[8] = {0,0,0,0,0,0,0,0};//æ•°ç ç®¡å°æ•°ç‚¹æ•°æ®å­˜æ”¾æ•°ç»„
  16          unsigned char Seg_Pos;//æ•°ç ç®¡æ‰«æä¸“ç”¨å˜é‡
  17          unsigned int Seg_Slow_Down;//æ•°ç ç®¡å‡é€Ÿä¸“ç”¨å˜é‡
  18          unsigned char ucLed[8] = {0,0,0,0,0,0,0,0};//Ledæ˜¾ç¤ºæ•°æ®å­˜æ”¾æ•°ç»„
  19          unsigned char Seg_Disp_Mode;//æ•°ç ç®¡æ˜¾ç¤ºæ¨¡å¼å˜é‡ 0-é¢‘ç‡ç•Œé¢ 1-æ¹¿åº¦ç•Œé¢ 2-æµ‹è·ç•Œé¢ 3-å
             -‚æ•°ç•Œé¢
  20          unsigned int Freq;//å®æ—¶é¢‘ç‡å€¼
  21          unsigned int Timer_1000Ms;//ä¸€åƒæ¯«ç§’è®¡æ—¶å˜é‡
  22          bit Hz_Unit_Flag;//å˜é‡å•ä½æ ‡å¿—ä½ 0-HZ 1-KHZ
  23          bit Cm_Unit_Flag;//å˜é‡å•ä½æ ‡å¿—ä½ 0-CM 1-M
  24          unsigned char Humidity_Val;//å®æ—¶æ¹¿åº¦å˜é‡
  25          unsigned char Distance_Val;//å®æ—¶è·ç¦»å˜é‡
  26          unsigned char Param_Disp[3] = {90,40,6};//å‚æ•°æ•°æ®æ˜¾ç¤ºæ•°ç»„
  27          unsigned char Param_Ctrl[3] = {90,40,6};//å‚æ•°æ•°æ®æ§åˆ¶æ•°ç»„
  28          unsigned char Param_Index;//å‚æ•°æ•°æ®æŒ‡é’ˆ
  29          code unsigned char Change_Val[3] = {5,10,1};//å‚æ•°ä¿®æ”¹æ­¥è¿›å€¼
  30          code unsigned char Param_Max[3] = {120,60,12};//å‚æ•°ä¿®æ”¹ä¸Šé™å€¼
  31          code unsigned char Param_Min[3] = {10,10,1};//å‚æ•°ä¿®æ”¹ä¸‹é™å€¼
  32          float Output_Val;//è¾“å‡ºç”µå‹å˜é‡
  33          bit Relay_Flag;//ç»§ç”µå™¨ä½¿èƒ½æ ‡å¿—ä½
  34          unsigned char Relay_Count;//ç»§ç”µå™¨ä½¿èƒ½è®¡æ•°å˜é‡
  35          unsigned char PWM_Count;//è„‰å®½é¢‘ç‡è®¡æ•°å€¼ 1KHZ = 1MS
  36          unsigned char PWM_Level;//å ç©ºæ¯”æ•°æ®å‚¨å­˜å˜é‡
  37          unsigned char Timer_100Ms;//ä¸€ç™¾æ¯«ç§’è®¡æ—¶å˜é‡
  38          bit Led_Star_Flag;//Ledé—ªçƒæ ‡å¿—ä½
  39          unsigned int Timer_Key;//æŒ‰é”®è®¡æ—¶å˜é‡
  40          bit Key_Flag;//æŒ‰é”®é•¿çŸ­æŒ‰æ ‡å¿—ä½
  41          
  42          /* é”®ç›˜å¤„ç†å‡½æ•° */
  43          void Key_Proc()
  44          {
  45   1        unsigned char i;//å¾ªç¯ä¸“ç”¨å˜é‡
  46   1        if(Key_Slow_Down) return;
  47   1        Key_Slow_Down = 1;//é”®ç›˜å‡é€Ÿç¨‹åº
  48   1      
  49   1        Key_Val = Key_Read();//å®æ—¶è¯»å–é”®ç å€¼
  50   1        Key_Down = Key_Val & (Key_Old ^ Key_Val);//æ•æ‰æŒ‰é”®ä¸‹é™æ²¿
  51   1        Key_Up = ~Key_Val & (Key_Old ^ Key_Val);//æ•æ‰æŒ‰é”®ä¸Šé™æ²¿
  52   1        Key_Old = Key_Val;//è¾…åŠ©æ‰«æå˜é‡
  53   1      
C51 COMPILER V9.54   MAIN                                                                  04/30/2023 12:49:57 PAGE 2   

  54   1        
  55   1        if(Seg_Disp_Mode == 1) //å¤„äºæ¹¿åº¦ç•Œé¢
  56   1        {
  57   2          if(Key_Down == 7) //äº§ç”Ÿä¸‹é™æ²¿
  58   2            Key_Flag = 1;//ä½¿èƒ½æ ‡å¿—ä½
  59   2          if(Key_Up == 7) //äº§ç”Ÿä¸Šå‡æ²¿
  60   2          {
  61   3            Key_Flag = 0;//æ‹‰ä½æ ‡å¿—ä½
  62   3            if(Timer_Key > 1000) //æ‰§è¡Œé•¿æŒ‰æ“ä½œ
  63   3            {
  64   4              Relay_Count = 0;//è®¡æ•°å€¼æ¸…é›¶
  65   4              EEPROM_Write(&Relay_Count,0,1);//å‚¨å­˜è®¡æ•°å€¼
  66   4            }
  67   3            Timer_Key = 0;//å¤ä½è®¡æ—¶å˜é‡
  68   3          }
  69   2        }
  70   1        
  71   1        switch(Key_Down)
  72   1        {
  73   2          case 4://ç•Œé¢æŒ‰é”®
  74   2            if(++Seg_Disp_Mode == 4) 
  75   2            {
  76   3              Seg_Disp_Mode = 0;
  77   3              Param_Index = 0;//å¤ä½æ•°æ®æŒ‡é’ˆ
  78   3              for(i=0;i<3;i++) //ä¿å­˜å‚æ•°å˜é‡
  79   3                Param_Ctrl[i] = Param_Disp[i];
  80   3            }
  81   2          break;
  82   2          case 5://å‚æ•°æŒ‰é”®
  83   2            if(Seg_Disp_Mode == 3) //å¤„äºå‚æ•°è®¾ç½®ç•Œé¢
  84   2            {
  85   3              if(++Param_Index == 3)
  86   3                Param_Index = 0;
  87   3            }
  88   2          break;
  89   2          case 6://è‡ªåŠ æŒ‰é”®
  90   2            if(Seg_Disp_Mode == 3) //å¤„äºå‚æ•°è®¾ç½®ç•Œé¢
  91   2            {
  92   3              Param_Disp[Param_Index] += Change_Val[Param_Index];
  93   3              if(Param_Disp[Param_Index] > Param_Max[Param_Index]) //é™åˆ¶å‚æ•°ä¿®æ”¹ä¸Šé™
  94   3                Param_Disp[Param_Index] = Param_Min[Param_Index];
  95   3            }
  96   2            else if(Seg_Disp_Mode == 2) //å¤„äºè·ç¦»æ˜¾ç¤ºç•Œé¢
  97   2              Hz_Unit_Flag ^= 1;
  98   2          break;
  99   2          case 7://è‡ªå‡æŒ‰é”®
 100   2          {
 101   3            if(Seg_Disp_Mode == 3) //å¤„äºå‚æ•°è®¾ç½®ç•Œé¢
 102   3            {
 103   4              Param_Disp[Param_Index] -= Change_Val[Param_Index];
 104   4              if(Param_Disp[Param_Index] < Param_Min[Param_Index]) //é™åˆ¶å‚æ•°ä¿®æ”¹ä¸‹é™
 105   4                Param_Disp[Param_Index] = Param_Max[Param_Index];
 106   4            }
 107   3            else if(Seg_Disp_Mode == 0) //å¤„äºé¢‘ç‡æ˜¾ç¤ºç•Œé¢
 108   3              Cm_Unit_Flag ^= 1;        
 109   3          }
 110   2        }
 111   1      }
 112          
 113          /* ä¿¡æ¯å¤„ç†å‡½æ•° */
 114          void Seg_Proc()
 115          {
C51 COMPILER V9.54   MAIN                                                                  04/30/2023 12:49:57 PAGE 3   

 116   1        unsigned char Pos;//å¾ªç¯ä¸“ç”¨å˜é‡
 117   1      //  if(Seg_Slow_Down) return;
 118   1      //  Seg_Slow_Down = 1;//æ•°ç ç®¡å‡é€Ÿç¨‹åº
 119   1      
 120   1        /* æ•°æ®è¯»å–åŒºåŸŸ */
 121   1        switch(Seg_Slow_Down) //è½®è¯¢è¯»å–èŠ¯ç‰‡æ•°æ®
 122   1        {
 123   2          case 100:
 124   2            Seg_Slow_Down += 1;//æ‰§è¡Œä¸€æ¬¡é™åˆ¶è¯­å¥
 125   2            Humidity_Val = Ad_Read(0x43) / 51.0 * 20;//å®æ—¶é‡‡é›†æ¹¿åº¦
 126   2            if(Humidity_Val > 99) Humidity_Val = 99;//é™åˆ¶æ¹¿åº¦ä¸Šé™
 127   2            if(Humidity_Val < Param_Ctrl[1]) //æ¹¿åº¦å°äºå‚æ•°
 128   2              Output_Val = 1;
 129   2            else if(Humidity_Val > 80) //æ¹¿åº¦å¤§äº80%
 130   2              Output_Val = 5;
 131   2            else
 132   2              Output_Val = (4.0 / (80 - Param_Ctrl[1])) * (Humidity_Val - Param_Ctrl[1]) + 1;
 133   2          break;
 134   2          case 200:
 135   2            Seg_Slow_Down += 1;//æ‰§è¡Œä¸€æ¬¡é™åˆ¶è¯­å¥
 136   2            Distance_Val = Ut_Wave_Data();//å®æ—¶è¯»å–è·ç¦»å€¼
 137   2          break;
 138   2        }
 139   1        
 140   1        /* ä¿¡æ¯æ˜¾ç¤ºåŒºåŸŸ */
 141   1        if(!(Seg_Slow_Down % 10)) //é¿å…æ•°ç ç®¡é—ªçƒ
 142   1        {
 143   2          Seg_Slow_Down += 1;//æ‰§è¡Œä¸€æ¬¡é™åˆ¶è¯­å¥
 144   2          Seg_Buf[0] = 11 + Seg_Disp_Mode;//æ¨¡å¼æ ‡è¯†ç¬¦
 145   2          switch(Seg_Disp_Mode)
 146   2          {
 147   3            case 0://é¢‘ç‡ç•Œé¢
 148   3              Seg_Buf[3] = (Freq / (1000 * (int)Hz_Unit_Flag)) / 10000 % 10;
 149   3              Seg_Buf[4] = (Freq / (1000 * (int)Hz_Unit_Flag)) / 1000 % 10;
 150   3              Seg_Buf[5] = (Freq / (1000 * (int)Hz_Unit_Flag)) / 100 % 10;
 151   3              Seg_Buf[6] = (Freq / (1000 * (int)Hz_Unit_Flag)) / 10 % 10;
 152   3              Seg_Buf[7] = (Freq / (1000 * (int)Hz_Unit_Flag)) % 10;
 153   3              Seg_Point[6] = Hz_Unit_Flag;
 154   3              Pos = 3;//è®¾ç½®æ•°ç ç®¡æ‰«æèµ·å§‹ä½
 155   3              while(Seg_Buf[Pos] == 0) //é«˜ä½æœªå¯ç”¨æ•°ç ç®¡ç†„ç­
 156   3              {
 157   4                Seg_Buf[Pos] = 10;
 158   4                if(++Pos == (7 - (int)Hz_Unit_Flag)) break;
 159   4              }
 160   3            break;
 161   3            case 1://æ¹¿åº¦ç•Œé¢
 162   3              Seg_Buf[3] = Seg_Buf[4] = Seg_Buf[5] = 10;
 163   3              Seg_Buf[6] = Humidity_Val / 10;
 164   3              Seg_Buf[7] = Humidity_Val % 10;
 165   3              Seg_Point[6] = 0;
 166   3            break;
 167   3            case 2://è·ç¦»ç•Œé¢
 168   3              Seg_Buf[5] = Distance_Val / 100 % 10;
 169   3              Seg_Buf[6] = Distance_Val / 10 % 10;
 170   3              Seg_Buf[7] = Distance_Val % 10;
 171   3              Seg_Point[5] = Cm_Unit_Flag;
 172   3              if(Cm_Unit_Flag == 0)
 173   3              {
 174   4                Pos = 5;//è®¾ç½®æ•°ç ç®¡æ‰«æèµ·å§‹ä½
 175   4                while(Seg_Buf[Pos] == 0) //é«˜ä½æœªå¯ç”¨æ•°ç ç®¡ç†„ç­
 176   4                {
 177   5                  Seg_Buf[Pos] = 10;
C51 COMPILER V9.54   MAIN                                                                  04/30/2023 12:49:57 PAGE 4   

 178   5                  if(++Pos == 7) break;
 179   5                }
 180   4              }
 181   3            break;
 182   3            case 3://å‚æ•°ç•Œé¢
 183   3              Seg_Buf[1] = Param_Index + 1;
 184   3              Seg_Buf[5] = Param_Disp[Param_Index] / 100 % 10?Param_Disp[Param_Index] / 100 % 10:10;
 185   3              Seg_Buf[6] = Param_Disp[Param_Index] / 10 % 10;
 186   3              Seg_Buf[7] = Param_Disp[Param_Index] % 10;
 187   3              Seg_Point[6] = (Param_Index != 1);
 188   3            break;
 189   3          }
 190   2        }
 191   1      }
 192          
 193          /* å…¶ä»–æ˜¾ç¤ºå‡½æ•° */
 194          void Led_Proc()
 195          {
 196   1        unsigned char i;//å¾ªç¯ä¸“ç”¨å˜é‡
 197   1        /* Ledæ˜¾ç¤ºåŠŸèƒ½ */
 198   1        for(i=0;i<3;i++) //äº’æ–¥ç‚¹äº®
 199   1          ucLed[i] = Seg_Disp_Mode < 3?(i == Seg_Disp_Mode):(i == Param_Index) & Led_Star_Flag;
 200   1        ucLed[3] = Freq > (Param_Ctrl[0] * 100);//é¢‘ç‡æ¯”è¾ƒæŒ‡ç¤ºç¯
 201   1        ucLed[4] = Humidity_Val > Param_Ctrl[1];//æ¹¿åº¦æ¯”è¾ƒæŒ‡ç¤ºç¯
 202   1        ucLed[5] = Distance_Val > (Param_Ctrl[2] * 10);//æµ‹è·æ¯”è¾ƒæŒ‡ç¤ºç¯
 203   1        
 204   1        /* DACè¾“å‡ºåŠŸèƒ½ */
 205   1        Da_Write(Output_Val * 51);
 206   1        
 207   1        /* ç»§ç”µå™¨åŠŸèƒ½ */
 208   1        if(ucLed[5] != 1) //æµ‹è·ç»“æœå°äºå‚æ•°å€¼
 209   1        {
 210   2          Relay_Flag = 1;//æ‹‰é«˜æ ‡å¿—ä½
 211   2          Relay(0);//å…³é—­ç»§ç”µå™¨
 212   2        }
 213   1        else if(Relay_Flag == 1)
 214   1        {
 215   2          Relay_Flag = 0;//æ‹‰ä½æ ‡å¿—ä½
 216   2          Relay(1);//æ‰“å¼€ç»§ç”µå™¨
 217   2          Relay_Count++;//æ›´æ–°è®¡æ•°å€¼
 218   2          EEPROM_Write(&Relay_Count,0,1);//å‚¨å­˜è®¡æ•°å€¼
 219   2        }
 220   1        
 221   1        /* è„‰å†²è¾“å‡ºåŠŸèƒ½ */
 222   1        PWM_Level = ucLed[3]?8:2;
 223   1        
 224   1      }
 225          
 226          
 227          /* å®šæ—¶å™¨0ä¸­æ–­åˆå§‹åŒ–å‡½æ•° */
 228          void Timer0Init(void)   //@12.000MHz
 229          {
 230   1        AUXR &= 0x7F;   //å®šæ—¶å™¨æ—¶é’Ÿ12Tæ¨¡å¼
 231   1        TMOD &= 0xF0;   //è®¾ç½®å®šæ—¶å™¨æ¨¡å¼
 232   1        TMOD |= 0x05;   //è®¾ç½®å®šæ—¶å™¨æ¨¡å¼
 233   1        TL0 = 0;    //è®¾ç½®å®šæ—¶åˆå§‹å€¼
 234   1        TH0 = 0;    //è®¾ç½®å®šæ—¶åˆå§‹å€¼
 235   1        TF0 = 0;    //æ¸…é™¤TF0æ ‡å¿—
 236   1        TR0 = 1;    //å®šæ—¶å™¨0å¼€å§‹è®¡æ—¶
 237   1      }
 238          
 239          /* å®šæ—¶å™¨1ä¸­æ–­åˆå§‹åŒ–å‡½æ•° */
C51 COMPILER V9.54   MAIN                                                                  04/30/2023 12:49:57 PAGE 5   

 240          void Timer1Init(void)   //1æ¯«ç§’@12.000MHz
 241          {
 242   1        AUXR &= 0xBF;   //å®šæ—¶å™¨æ—¶é’Ÿ12Tæ¨¡å¼
 243   1        TMOD &= 0x0F;   //è®¾ç½®å®šæ—¶å™¨æ¨¡å¼
 244   1        TL1 = 0x18;   //è®¾ç½®å®šæ—¶åˆå§‹å€¼
 245   1        TH1 = 0xFC;   //è®¾ç½®å®šæ—¶åˆå§‹å€¼
 246   1        TF1 = 0;    //æ¸…é™¤TF1æ ‡å¿—
 247   1        TR1 = 1;    //å®šæ—¶å™¨1å¼€å§‹è®¡æ—¶
 248   1        ET1 = 1;    //å®šæ—¶å™¨ä¸­æ–­1æ‰“å¼€
 249   1        EA = 1;     //æ€»ä¸­æ–­æ‰“å¼€ 
 250   1      }
 251          
 252          /* å®šæ—¶å™¨2ä¸­æ–­åˆå§‹åŒ–å‡½æ•° */
 253          void Timer2Init(void)   //100å¾®ç§’@12.000MHz
 254          {
 255   1        AUXR &= 0xFB;   //å®šæ—¶å™¨æ—¶é’Ÿ12Tæ¨¡å¼
 256   1        T2L = 0x9C;   //è®¾ç½®å®šæ—¶åˆå§‹å€¼
 257   1        T2H = 0xFF;   //è®¾ç½®å®šæ—¶åˆå§‹å€¼
 258   1        AUXR |= 0x10;   //å®šæ—¶å™¨2å¼€å§‹è®¡æ—¶
 259   1        IE2 |= (1<<2);   //å®šæ—¶å™¨ä¸­æ–­2æ‰“å¼€
 260   1      }
 261          
 262          /* å®šæ—¶å™¨0ä¸­æ–­æœåŠ¡å‡½æ•° */
 263          void Timer0Server() interrupt 3
 264          {  
 265   1        if(++Key_Slow_Down == 10) Key_Slow_Down = 0;//é”®ç›˜å‡é€Ÿä¸“ç”¨
 266   1        if(++Seg_Slow_Down == 500) Seg_Slow_Down = 0;//æ•°ç ç®¡å‡é€Ÿä¸“ç”¨
 267   1        if(++Seg_Pos == 8) Seg_Pos = 0;//æ•°ç ç®¡æ˜¾ç¤ºä¸“ç”¨
 268   1        Seg_Disp(Seg_Pos,Seg_Buf[Seg_Pos],Seg_Point[Seg_Pos]);
 269   1        Led_Disp(Seg_Pos,ucLed[Seg_Pos]);
 270   1        
 271   1        if(++Timer_1000Ms == 1000)
 272   1        {
 273   2          TR0 = 0;
 274   2          Timer_1000Ms = 0;
 275   2          Freq = TH0 << 8 | TL0;
 276   2          TH0 = TL0 = 0;
 277   2          TR0 = 1;
 278   2        }
 279   1        
 280   1        if(++Timer_100Ms == 100)
 281   1        {
 282   2          Timer_100Ms = 0;
 283   2          Led_Star_Flag ^= 1; 
 284   2        }
 285   1        
 286   1        if(Key_Flag == 1)
 287   1        {
 288   2          if(++Timer_Key > 1200) //é˜²æ­¢ä¸€ç›´é•¿æŒ‰è®¡æ—¶å˜é‡æº¢å‡º
 289   2            Timer_Key = 1200;
 290   2        }
 291   1      }
 292          
 293          /* å®šæ—¶å™¨2ä¸­æ–­æœåŠ¡å‡½æ•° */
 294          void Timer2Server() interrupt 12
 295          {
 296   1        if(++PWM_Count == 10) PWM_Count = 0;//è„‰å†²å‘¨æœŸä¸º1MS
 297   1        Pulse(PWM_Count < PWM_Level);//PWMè¾“å‡º
 298   1      }
 299          
 300          /* Main */
 301          void main()
C51 COMPILER V9.54   MAIN                                                                  04/30/2023 12:49:57 PAGE 6   

 302          {
 303   1        System_Init();
 304   1        EEPROM_Read(&Relay_Count,0,1);//è¯»å–è®¡æ•°å€¼
 305   1        Timer0Init();
 306   1        Timer2Init();
 307   1        Timer1Init();
 308   1        while (1)
 309   1        {
 310   2          Key_Proc();
 311   2          Seg_Proc();
 312   2          Led_Proc();
 313   2        }
 314   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1512    ----
   CONSTANT SIZE    =      9    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     56       1
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      5    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
