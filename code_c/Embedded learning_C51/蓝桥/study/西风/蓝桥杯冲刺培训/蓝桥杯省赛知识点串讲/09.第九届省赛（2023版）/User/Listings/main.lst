C51 COMPILER V9.54   MAIN                                                                  02/05/2023 11:06:39 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\Driver) DEBUG OBJECTEXTEND PRI
                    -NT(.\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          /* 头文件声明区 */
   2          #include <STC15F2K60S2.H>//单片机寄存器专用头文件
   3          #include <Init.h>//初始化底层驱动专用头文件
   4          #include <Led.h>//Led底层驱动专用头文件
   5          #include <Key.h>//按键底层驱动专用头文件
   6          #include <Seg.h>//数码管底层驱动专用头文件
   7          #include "iic.h"//单总线底层驱动专用头文件
   8          
   9          /* 变量声明区 */
  10          unsigned char Key_Val,Key_Down,Key_Old,Key_Up;//按键专用变量
  11          unsigned char Key_Slow_Down;//按键减速专用变量
  12          unsigned char Seg_Buf[8] = {10,10,10,10,10,10,10,10};//数码管显示数据存放数组
  13          unsigned char Seg_Point[8] = {0,0,0,0,0,0,0,0};//数码管小数点数据存放数组
  14          unsigned char Seg_Pos;//数码管扫描专用变量
  15          unsigned int Seg_Slow_Down;//数码管减速专用变量
  16          unsigned char ucLed[8] = {0,0,0,0,0,0,0,0};//Led显示数据存放数组
  17          bit Seg_Disp_Mode;//数码管显示模式变量 0-设置界面 1-亮度等级界面
  18          unsigned int Led_Time_Disp[4] = {400,400,400,400};//Led流转时间间隔显示数组
  19          unsigned int Led_Time_Ctrol[4] = {400,400,400,400};//Led流转时间间隔控制数组
  20          unsigned char Led_Time_Index;//Led流转数组指针
  21          unsigned char Seg_Star_Index;//数码管闪烁指针 0-熄灭 1-运行模式编号 2-流转时间间隔
  22          unsigned int Timer_400Ms;//400毫秒计时变量
  23          bit Seg_Star_Flag;//数码管闪烁标志位
  24          unsigned int Ms_Tick;//系统计时变量
  25          bit Start_Flag;//流转启动标志位 0-暂停 1-启动
  26          unsigned char Led_Mode;//系统流转模式变量
  27          unsigned char Led_Pos;//Led流转专用变量
  28          unsigned char EEPROM_Dat[4];//EEPROM专用数组
  29          unsigned char Led_Level;//Led亮度等级变量
  30          unsigned char Led_Count;//Led计数变量
  31          unsigned char Pos_125us;//125微妙扫描变量
  32          
  33          /* 键盘处理函数 */
  34          void Key_Proc()
  35          {
  36   1        unsigned char i;//For循环专用变量
  37   1        if(Key_Slow_Down) return;
  38   1        Key_Slow_Down = 1;//键盘减速程序
  39   1      
  40   1        Key_Val = Key_Read();//实时读取键码值
  41   1        Key_Down = Key_Val & (Key_Old ^ Key_Val);//捕捉按键下降沿
  42   1        Key_Up = ~Key_Val & (Key_Old ^ Key_Val);//捕捉按键上降沿
  43   1        Key_Old = Key_Val;//辅助扫描变量
  44   1      
  45   1        if(Seg_Star_Index == 0) //处于非设置状态
  46   1        {
  47   2          if(Key_Old == 4) //长按S4
  48   2            Seg_Disp_Mode = 1;//切换到亮度等级显示界面
  49   2          else
  50   2            Seg_Disp_Mode = 0;//切换回数据显示界面
  51   2        }
  52   1        
  53   1        switch(Key_Down)
  54   1        {
C51 COMPILER V9.54   MAIN                                                                  02/05/2023 11:06:39 PAGE 2   

  55   2          case 6://设置按键
  56   2            if(++Seg_Star_Index == 3)
  57   2              Seg_Star_Index = 0;
  58   2            if(Seg_Star_Index == 0) //退出设置界面
  59   2            {
  60   3              Led_Time_Index = 0;//复位指针值
  61   3              for(i=0;i<4;i++)
  62   3              {
  63   4                Led_Time_Ctrol[i] = Led_Time_Disp[i];//保存设置参数
  64   4                EEPROM_Dat[i] = Led_Time_Ctrol[i] / 100;//EEPROM数据处理
  65   4              }
  66   3              EEPROM_Write(EEPROM_Dat,0,4);//将数据保存到EEPROM中
  67   3            }
  68   2          break;
  69   2          case 7://启动按键
  70   2            Start_Flag ^= 1;
  71   2          break;
  72   2          case 5://自加按键
  73   2            if(Seg_Star_Index == 1) //选中参数编号
  74   2            {
  75   3              if(++Led_Time_Index == 4) //四种模式循环切换
  76   3                Led_Time_Index = 0;
  77   3            }
  78   2            else if(Seg_Star_Index == 2) //选中流转间隔
  79   2            {
  80   3              Led_Time_Disp[Led_Time_Index] += 100;
  81   3              if(Led_Time_Disp[Led_Time_Index] > 1200) //限制上限为1200
  82   3                Led_Time_Disp[Led_Time_Index] = 1200;
  83   3            }
  84   2          break;
  85   2          case 4://自减按键
  86   2            if(Seg_Star_Index == 1) //选中参数编号
  87   2            {
  88   3              if(--Led_Time_Index == 255) //四种模式循环切换
  89   3                Led_Time_Index = 3;
  90   3            }
  91   2            else if(Seg_Star_Index == 2) //选中流转间隔
  92   2            {
  93   3              Led_Time_Disp[Led_Time_Index] -= 100;
  94   3              if(Led_Time_Disp[Led_Time_Index] < 400) //限制下限为400
  95   3                Led_Time_Disp[Led_Time_Index] = 400;
  96   3            }
  97   2          break;
  98   2        }
  99   1      }
 100          
 101          /* 信息处理函数 */
 102          void Seg_Proc()
 103          {
 104   1        unsigned char i;//For循环专用变量
 105   1        if(Seg_Slow_Down) return;
 106   1        Seg_Slow_Down = 1;//数码管减速程序
 107   1      
 108   1        Led_Level = Ad_Read(0x03) / 64;//实时获取亮度等级
 109   1        
 110   1        if(Seg_Disp_Mode == 0) //处于设置界面
 111   1        {
 112   2          Seg_Buf[0] = Seg_Buf[2] = 11;
 113   2          Seg_Buf[1] = Led_Time_Index+1;
 114   2          Seg_Buf[4] = Led_Time_Disp[Led_Time_Index] / 1000 % 10;
 115   2          Seg_Buf[5] = Led_Time_Disp[Led_Time_Index] / 100 % 10;
 116   2          Seg_Buf[6] = Led_Time_Disp[Led_Time_Index] / 10 % 10;
C51 COMPILER V9.54   MAIN                                                                  02/05/2023 11:06:39 PAGE 3   

 117   2          Seg_Buf[7] = Led_Time_Disp[Led_Time_Index] % 10;
 118   2          if(Seg_Star_Index == 0) //熄灭
 119   2          {
 120   3            for(i=0;i<8;i++)
 121   3              Seg_Buf[i] = 10;
 122   3          }
 123   2          else if(Seg_Star_Index == 1) //运行编号闪烁
 124   2          {
 125   3            Seg_Buf[0] = Seg_Buf[2] = Seg_Star_Flag?10:11;
 126   3            Seg_Buf[1] = Seg_Star_Flag?10:Led_Time_Index+1;     
 127   3          }
 128   2          else //流转时间间隔闪烁
 129   2          {
 130   3            Seg_Buf[4] = Seg_Star_Flag?10:Led_Time_Disp[Led_Time_Index] / 1000 % 10;
 131   3            Seg_Buf[5] = Seg_Star_Flag?10:Led_Time_Disp[Led_Time_Index] / 100 % 10;
 132   3            Seg_Buf[6] = Seg_Star_Flag?10:Led_Time_Disp[Led_Time_Index] / 10 % 10;
 133   3            Seg_Buf[7] = Seg_Star_Flag?10:Led_Time_Disp[Led_Time_Index] % 10;     
 134   3          }
 135   2          if(Seg_Buf[4] == 0) Seg_Buf[4] = 10;//只有最高位需要考虑是否高位熄灭
 136   2        }
 137   1        else//处于亮度等级界面
 138   1        {
 139   2          Seg_Buf[6] = 11;
 140   2          Seg_Buf[7] = Led_Level+1;
 141   2        }
 142   1      }
 143          
 144          /* 其他显示函数 */
 145          void Led_Proc()
 146          {
 147   1        unsigned char i;//For循环专用变量
 148   1        if(Start_Flag == 1) //系统处于启动状态
 149   1        {
 150   2          if(Ms_Tick == Led_Time_Ctrol[Led_Mode]) //系统计时时间达到流转时间间隔
 151   2          {
 152   3            Ms_Tick = 0;//复位计时 便于下次进入
 153   3            switch(Led_Mode)
 154   3            {
 155   4              case 0://模式1-从L1到L8
 156   4                if(++Led_Pos == 8)
 157   4                {
 158   5                  Led_Pos = 7;//模式2起始值
 159   5                  Led_Mode = 1;//切换到模式2
 160   5                }
 161   4              break;
 162   4              case 1://模式2-从L8到L1
 163   4                if(--Led_Pos == 255)
 164   4                {
 165   5                  Led_Pos = 07;//模式3起始值
 166   5                  Led_Mode = 2;//切换到模式3
 167   5                }
 168   4              break;
 169   4              case 2://模式3-07 16 25 34
 170   4                Led_Pos += 9;
 171   4                if(Led_Pos > 34)
 172   4                {
 173   5                  Led_Pos = 34;//模式4起始值
 174   5                  Led_Mode = 3;//切换到模式4
 175   5                }
 176   4              break;
 177   4              case 3://模式4-34 25 16 07
 178   4                Led_Pos -= 9;
C51 COMPILER V9.54   MAIN                                                                  02/05/2023 11:06:39 PAGE 4   

 179   4                if(Led_Pos > 200)
 180   4                {
 181   5                  Led_Pos = 0;//模式1起始值
 182   5                  Led_Mode = 0;//切换到模式1
 183   5                }
 184   4              break;
 185   4            }
 186   3          }
 187   2        }
 188   1        
 189   1      //  if(Led_Mode <= 1) //系统处于前两种流转模式时
 190   1      //  {
 191   1      //    for(i=0;i<8;i++)
 192   1      //     ucLed[i] = (i == Led_Pos);
 193   1      //  }
 194   1      //  else //系统处于后两种流转模式时
 195   1      //  {
 196   1      //    for(i=0;i<8;i++)
 197   1      //      ucLed[i] = ((i == (Led_Pos / 10)) || (i == (Led_Pos % 10))); //点亮十位跟个位所对应的Led
 198   1      //  }
 199   1        
 200   1        //两种情况可合并简化成一种 只需要屏蔽掉在前两种模式0X的时候 十位也会满足
             -逻辑为真的情况
 201   1        for(i=0;i<8;i++)
 202   1          ucLed[i] = ((i == (Led_Pos / 10) & (Led_Mode / 2)) || (i == (Led_Pos % 10)));
 203   1      }
 204          
 205          /* 定时器1中断初始化函数 */
 206          void Timer1Init(void)   //125微秒@12.000MHz
 207          {
 208   1        AUXR &= 0xBF;   //定时器时钟12T模式
 209   1        TMOD &= 0x0F;   //设置定时器模式
 210   1        TL1 = 0x83;   //设置定时初始值
 211   1        TH1 = 0xFF;   //设置定时初始值
 212   1        TF1 = 0;    //清除TF1标志
 213   1        TR1 = 1;    //定时器1开始计时
 214   1        ET1 = 1;    //定时器中断1打开
 215   1      }
 216          
 217          /* 定时器0中断初始化函数 */
 218          void Timer0Init(void)   //1毫秒@12.000MHz
 219          {
 220   1        AUXR &= 0x7F;   //定时器时钟12T模式
 221   1        TMOD &= 0xF0;   //设置定时器模式
 222   1        TL0 = 0x18;   //设置定时初始值
 223   1        TH0 = 0xFC;   //设置定时初始值
 224   1        TF0 = 0;    //清除TF0标志
 225   1        TR0 = 1;    //定时器0开始计时
 226   1        ET0 = 1;    //定时器中断0打开
 227   1        EA = 1;     //总中断打开
 228   1      }
 229          
 230          /* 定时器1中断服务函数 */
 231          void Timer1Server() interrupt 3
 232          { 
 233   1        if(++Pos_125us == 8) Pos_125us = 0;//一个完整的扫描周期为1毫秒
 234   1        if(Led_Count <= (Led_Level*4)) //12毫秒的周期中均分四个亮度等级 0 4 8 12
 235   1          Led_Disp(Pos_125us,ucLed[Pos_125us]);
 236   1        else
 237   1          Led_Disp(Pos_125us,0);
 238   1        /* 
 239   1          Led采用的动态扫描的思路 即需要扫描8次才算一个完整的显示周期
C51 COMPILER V9.54   MAIN                                                                  02/05/2023 11:06:39 PAGE 5   

 240   1          如果继续放在定时器0中断内扫描的话 需要8毫秒才能实现一次扫描
 241   1          这样的话 会因为扫描周期较长 无法实现亮度等级的变化（会因为周期长而看起
             -来闪烁 而不是亮度变暗）
 242   1          所以需要生成一个125微妙的定时器中断 这样实现一个完整的扫描周期需要1毫秒
 243   1        */
 244   1      }
 245          
 246          /* 定时器0中断服务函数 */
 247          void Timer0Server() interrupt 1
 248          {  
 249   1        if(++Key_Slow_Down == 10) Key_Slow_Down = 0;//键盘减速专用
 250   1        if(++Seg_Slow_Down == 500) Seg_Slow_Down = 0;//数码管减速专用
 251   1        if(++Seg_Pos == 8) Seg_Pos = 0;//数码管显示专用
 252   1        Seg_Disp(Seg_Pos,Seg_Buf[Seg_Pos],Seg_Point[Seg_Pos]);
 253   1        if(++Led_Count == 13) Led_Count = 0;//Led一个显示周期为12毫秒
 254   1      
 255   1        if(++Timer_400Ms == 400) //四百毫秒取反一次
 256   1        {
 257   2          Timer_400Ms = 0;
 258   2          Seg_Star_Flag ^= 1;
 259   2        }
 260   1        
 261   1        if(Start_Flag == 1) //系统启动时开始计时
 262   1          Ms_Tick++;
 263   1        
 264   1        Seg_Proc();
 265   1        /* 
 266   1          如果放在While内循环扫描 定时器1中断触发频率较高
 267   1          程序没有执行完就会被中断打断 所以会出现数码管数据会出现异常闪烁的情况
 268   1          所以需要将此函数放到中断里面执行 保证函数不会被中断给打断 能完整执行
 269   1        */
 270   1      }
 271          
 272          /* Main */
 273          void main()
 274          {
 275   1        unsigned char i;//For循环专用变量
 276   1        EEPROM_Read(EEPROM_Dat,0,4);//读取EEPROM数据
 277   1        for(i=0;i<4;i++)
 278   1         Led_Time_Ctrol[i] = Led_Time_Disp[i] = EEPROM_Dat[i] * 100;//数据处理
 279   1        System_Init();
 280   1        Timer0Init();
 281   1        Timer1Init();
 282   1        while (1)
 283   1        {
 284   2          Key_Proc();
 285   2          //Seg_Proc();
 286   2          Led_Proc();
 287   2        }
 288   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1189    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     63    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      3    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
