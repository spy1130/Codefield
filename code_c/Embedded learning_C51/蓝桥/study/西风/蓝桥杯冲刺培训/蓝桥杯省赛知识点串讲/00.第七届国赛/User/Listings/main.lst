C51 COMPILER V9.54   MAIN                                                                  04/02/2023 17:20:47 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\Driver) DEBUG OBJECTEXTEND PRI
                    -NT(.\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          /* 头文件声明区 */
   2          #include <STC15F2K60S2.H>//单片机寄存器专用头文件
   3          #include <Init.h>//初始化底层驱动专用头文件
   4          #include <Led.h>//Led底层驱动专用头文件
   5          #include <Key.h>//按键底层驱动专用头文件
   6          #include <Seg.h>//数码管底层驱动专用头文件
   7          #include "ds1302.h"//时钟底层驱动专用头文件
   8          #include "iic.h"//单总线底层驱动专用头文件
   9          
  10          /* 变量声明区 */
  11          unsigned char Key_Val,Key_Down,Key_Old,Key_Up;//按键专用变量
  12          unsigned char Key_Slow_Down;//按键减速专用变量
  13          unsigned char Seg_Buf[8] = {10,10,10,10,10,10,10,10};//数码管显示数据存放数组
  14          unsigned char Seg_Point[8] = {0,0,0,0,0,0,0,0};//数码管小数点数据存放数组
  15          unsigned char Seg_Pos;//数码管扫描专用变量
  16          unsigned int Seg_Slow_Down;//数码管减速专用变量
  17          unsigned char ucLed[8] = {0,0,0,0,0,0,0,0};//Led显示数据存放数组
  18          unsigned char Seg_Disp_Mode = 8;//数码管显示模式变量 0-时钟显示 1-时钟设置 2-电压测量
             - 3-阈值设置 4-频率测量 5-周期显示 6-事件类型 7-事件时间
  19          unsigned char ucRtc[3] = {23,59,55};//时钟数据储存数组 上电默认时间23:59:55
  20          unsigned char ucRtc_Set[3];//时钟数据设置数组
  21          unsigned char ucRtc_Set_Index;//时钟数据设置数组指针
  22          unsigned int Voltage;//实时电压采集变量
  23          unsigned char Voltage_Val_Disp[2] = {20,10};//电压阈值上下限显示数组
  24          unsigned char Voltage_Val_Ctrol[2] = {20,10};//电压阈值上下限控制数组
  25          bit Voltage_Val_Index;//电压阈值控制数组指针
  26          unsigned int Timer_1000Ms;//1000毫秒计时变量
  27          unsigned int Freq;//实时频率采集变量
  28          unsigned int Cycle;//实时周期采集变量
  29          bit Seg_Star_Flag;//数码管闪烁标志位
  30          unsigned char Event_Type;//事件类型 0-低于下限事件 1-高于上限事件
  31          bit Event_Flag = 1;//事件异常标志位 0-正常 1-异常
  32          unsigned char Event_Time[3];//异常触发事件记录数组
  33          
  34          /* 延时函数 */
  35          void Delay200ms()   //@12.000MHz
  36          {
  37   1        unsigned char i, j, k;
  38   1        i = 10;
  39   1        j = 31;
  40   1        k = 147;
  41   1        do
  42   1        {
  43   2          do
  44   2          {
  45   3            while (--k);
  46   3          } while (--j);
  47   2        } while (--i);
  48   1      }
  49          
  50          
  51          /* 键盘处理函数 */
  52          void Key_Proc()
  53          {
C51 COMPILER V9.54   MAIN                                                                  04/02/2023 17:20:47 PAGE 2   

  54   1        unsigned char i;//循环专用变量
  55   1        if(Key_Slow_Down) return;
  56   1        Key_Slow_Down = 1;//键盘减速程序
  57   1      
  58   1        Key_Val = Key_Read();//实时读取键码值
  59   1        Key_Down = Key_Val & (Key_Old ^ Key_Val);//捕捉按键下降沿
  60   1        Key_Up = ~Key_Val & (Key_Old ^ Key_Val);//捕捉按键上降沿
  61   1        Key_Old = Key_Val;//辅助扫描变量
  62   1      
  63   1        switch(Key_Down)
  64   1        {
  65   2          case 7://时钟显示按键
  66   2            if(Seg_Disp_Mode != 1) //处于非时钟设置界面
  67   2              Seg_Disp_Mode = 0;//切换到时钟显示界面
  68   2            else
  69   2            {
  70   3              Set_Rtc(ucRtc_Set);//重新设置时钟数据
  71   3              Read_Rtc(ucRtc);//读取一次更新时钟值
  72   3              Seg_Disp_Mode = 0;//切换到时钟显示界面
  73   3            }
  74   2          break;
  75   2          case 6://电压显示按键
  76   2            if(Seg_Disp_Mode != 3) //处于非阈值设置界面
  77   2              Seg_Disp_Mode = 2;//切换到电压显示界面
  78   2            else
  79   2            {
  80   3              if(Voltage_Val_Disp[0] > Voltage_Val_Disp[1])//判断数据有效性
  81   3              {
  82   4                EEPROM_Write(Voltage_Val_Disp,0,2);//将阈值写入芯片
  83   4                Voltage_Val_Ctrol[0] = Voltage_Val_Disp[0];//保存设置阈值
  84   4                Voltage_Val_Ctrol[1] = Voltage_Val_Disp[1];
  85   4              }
  86   3              else
  87   3              {
  88   4                Voltage_Val_Disp[0] = Voltage_Val_Ctrol[0];//还原设置阈值
  89   4                Voltage_Val_Disp[1] = Voltage_Val_Ctrol[1];         
  90   4              }
  91   3              Seg_Disp_Mode = 2;//切换到电压显示界面
  92   3            }
  93   2          break;
  94   2          case 5://频率显示按键
  95   2            if(Seg_Disp_Mode != 5) //处于非周期设置界面
  96   2              Seg_Disp_Mode = 4;//切换到频率显示界面
  97   2          break;
  98   2          case 9://事件时间按键
  99   2            if(Seg_Disp_Mode != 7) //处于非事件时间界面
 100   2              Seg_Disp_Mode = 6;//切换到事件类型界面
 101   2          break;
 102   2          case 4://功能切换按键
 103   2            switch(Seg_Disp_Mode)
 104   2            {
 105   3              case 0://处于时钟显示界面
 106   3                for(i=0;i<3;i++) //记录设置记录时间
 107   3                  ucRtc_Set[i] = ucRtc[i];
 108   3                ucRtc_Set_Index = 0;//指针值复位
 109   3                Seg_Disp_Mode = 1;//切换到时钟设置界面
 110   3              break;
 111   3              case 1://处于时钟设置界面
 112   3                if(++ucRtc_Set_Index == 3) ucRtc_Set_Index = 0;//时分秒循环切换
 113   3              break;
 114   3              case 2://处于电压显示界面
 115   3                Voltage_Val_Index = 0;//指针值复位
C51 COMPILER V9.54   MAIN                                                                  04/02/2023 17:20:47 PAGE 3   

 116   3                Seg_Disp_Mode = 3;//切换到阈值设置界面
 117   3              break;
 118   3              case 3://处于阈值设置界面
 119   3                Voltage_Val_Index ^= 1;//上下限循环切换
 120   3              break;
 121   3              case 4://处于频率显示界面
 122   3                Seg_Disp_Mode = 5;//切换到周期显示界面
 123   3              break;
 124   3              case 5://处于周期显示界面
 125   3                Seg_Disp_Mode = 4;//切换到频率显示界面
 126   3              break;
 127   3              case 6://处于事件类型界面
 128   3                Seg_Disp_Mode = 7;//切换到事件时间界面
 129   3              break;
 130   3              case 7://处于事件时间界面
 131   3                Seg_Disp_Mode = 6;//切换到事件类型界面
 132   3              break;
 133   3            }
 134   2          break;
 135   2          case 11://参数自加按键
 136   2            if(Seg_Disp_Mode == 1) //处于时钟设置界面
 137   2            {
 138   3              if(++ucRtc_Set[ucRtc_Set_Index] == (ucRtc_Set_Index?60:24))
 139   3                ucRtc_Set[ucRtc_Set_Index] = ucRtc_Set_Index?59:23;
 140   3            }
 141   2            else if(Seg_Disp_Mode == 3) //处于阈值设置界面
 142   2            {
 143   3              Voltage_Val_Disp[Voltage_Val_Index] += 5;
 144   3              if(Voltage_Val_Disp[Voltage_Val_Index] > 50)
 145   3                Voltage_Val_Disp[Voltage_Val_Index] = 50;
 146   3            }
 147   2          break;
 148   2          case 10://参数自减按键
 149   2            if(Seg_Disp_Mode == 1) //处于时钟设置界面
 150   2            {
 151   3              if(--ucRtc_Set[ucRtc_Set_Index] == 255)
 152   3                ucRtc_Set[ucRtc_Set_Index] = 0;
 153   3            }
 154   2            else if(Seg_Disp_Mode == 3) //处于阈值设置界面
 155   2            {
 156   3              Voltage_Val_Disp[Voltage_Val_Index] -= 5;
 157   3              if(Voltage_Val_Disp[Voltage_Val_Index] > 200)
 158   3                Voltage_Val_Disp[Voltage_Val_Index] = 0;
 159   3            }
 160   2          break;
 161   2        }
 162   1      }
 163          
 164          /* 信息处理函数 */
 165          void Seg_Proc()
 166          {
 167   1        unsigned char i;//循环专用变量
 168   1        
 169   1        /* 
 170   1          减速的实际意义是避免程序循环执行过快导致的芯片数据读取出错
 171   1          在题目中出现多个芯片时 可设计不同的减速执行周期 达到轮询读取的效果
 172   1          避免单片机在某一时刻读取多个芯片所导致的效率较慢或数据错误的问题
 173   1        */
 174   1        
 175   1        switch(Seg_Slow_Down)
 176   1        {
 177   2          case 200:
C51 COMPILER V9.54   MAIN                                                                  04/02/2023 17:20:47 PAGE 4   

 178   2            Seg_Slow_Down += 1;
 179   2            Read_Rtc(ucRtc);//实时读取时钟值
 180   2            Seg_Star_Flag = ucRtc[2] % 2;//使用秒钟界定闪烁时间
 181   2          break;
 182   2          case 300:
 183   2            Seg_Slow_Down += 1;
 184   2            Voltage = (unsigned int)((Ad_Read(0x43) / 51.0) * 1000);//实时读取电压值
 185   2          break;
 186   2          case 400:
 187   2            if(Voltage >= (Voltage_Val_Ctrol[1] * 100) && Voltage < (Voltage_Val_Ctrol[0] * 100)) //正常事件
 188   2              Event_Flag = 0;
 189   2            else if(Event_Flag == 0)
 190   2            {
 191   3              Event_Flag = 1;//异常事件
 192   3              Read_Rtc(Event_Time);//读取异常事件
 193   3              Event_Type = (bit)(Voltage / (Voltage_Val_Ctrol[0] * 100));
 194   3              EEPROM_Write(Event_Time,8,3);//保存事件变量
 195   3              Delay200ms();
 196   3              EEPROM_Write(&Event_Type,3,1);//保存类型变量
 197   3            }
 198   2            
 199   2            switch(Seg_Disp_Mode)
 200   2            {
 201   3              case 0://时钟显示
 202   3                Seg_Buf[2] = Seg_Buf[5] = 11;
 203   3                for(i=0;i<3;i++)
 204   3                {
 205   4                  Seg_Buf[3*i] = ucRtc[i] / 10;
 206   4                  Seg_Buf[3*i+1] = ucRtc[i] % 10;
 207   4                }
 208   3              break;
 209   3              case 1://时钟设置
 210   3                Seg_Buf[2] = Seg_Buf[5] = 11;
 211   3                for(i=0;i<3;i++)
 212   3                {
 213   4                  Seg_Buf[3*i] = ucRtc_Set[i] / 10;
 214   4                  Seg_Buf[3*i+1] = ucRtc_Set[i] % 10;
 215   4                }
 216   3                Seg_Buf[3*ucRtc_Set_Index] = Seg_Star_Flag?ucRtc_Set[ucRtc_Set_Index] / 10:10;
 217   3                Seg_Buf[3*ucRtc_Set_Index+1] = Seg_Star_Flag?ucRtc_Set[ucRtc_Set_Index] % 10:10;
 218   3              break;
 219   3              case 2://电压显示
 220   3                Seg_Buf[0] = Seg_Buf[2] = 11;
 221   3                Seg_Buf[1] = 1;
 222   3                Seg_Buf[3] = 10;
 223   3                Seg_Buf[4] = Voltage / 1000 % 10;
 224   3                Seg_Buf[5] = Voltage / 100 % 10;
 225   3                Seg_Buf[6] = Voltage / 10 % 10;
 226   3                Seg_Buf[7] = Voltage % 10;
 227   3              break;
 228   3              case 3://阈值显示
 229   3                Seg_Buf[2] = Seg_Buf[3] = Voltage_Val_Index?0:(Seg_Star_Flag?10:0);
 230   3                Seg_Buf[6] = Seg_Buf[7] = Voltage_Val_Index?(Seg_Star_Flag?10:0):0;
 231   3                for(i=0;i<2;i++)
 232   3                {
 233   4                  Seg_Buf[4*i] =  Voltage_Val_Disp[i] / 10;
 234   4                  Seg_Buf[4*i+1] =  Voltage_Val_Disp[i] % 10;
 235   4                }
 236   3                Seg_Buf[4*Voltage_Val_Index] =  Seg_Star_Flag?10:Voltage_Val_Disp[Voltage_Val_Index] / 10;
 237   3                Seg_Buf[4*Voltage_Val_Index+1] = Seg_Star_Flag?10:Voltage_Val_Disp[Voltage_Val_Index] % 10;
 238   3              break;
 239   3              case 4://频率显示
C51 COMPILER V9.54   MAIN                                                                  04/02/2023 17:20:47 PAGE 5   

 240   3                Seg_Buf[0] = Seg_Buf[2] = 11;
 241   3                Seg_Buf[1] = 2;
 242   3                Seg_Buf[3] = Freq / 10000 % 10;
 243   3                Seg_Buf[4] = Freq / 1000 % 10;
 244   3                Seg_Buf[5] = Freq / 100 % 10;
 245   3                Seg_Buf[6] = Freq / 10 % 10;
 246   3                Seg_Buf[7] = Freq % 10;
 247   3              break;
 248   3              case 5://周期显示
 249   3                Cycle = 10000 / Freq;
 250   3                Seg_Buf[0] = Seg_Buf[2] = 11;
 251   3                Seg_Buf[1] = 2;
 252   3                Seg_Buf[3] = Cycle / 10000 % 10;
 253   3                Seg_Buf[4] = Cycle / 1000 % 10;
 254   3                Seg_Buf[5] = Cycle / 100 % 10;
 255   3                Seg_Buf[6] = Cycle / 10 % 10;
 256   3                Seg_Buf[7] = Cycle % 10;        
 257   3              break;
 258   3              case 6://事件类型
 259   3                for(i=0;i<6;i++)
 260   3                  Seg_Buf[i] = 10;
 261   3                Seg_Buf[6] = 0;
 262   3                Seg_Buf[7] = Event_Type;
 263   3              break;
 264   3              case 7://事件事件
 265   3                Seg_Buf[2] = Seg_Buf[5] = 11;
 266   3                for(i=0;i<3;i++)
 267   3                {
 268   4                  Seg_Buf[3*i] = Event_Time[i] / 10;
 269   4                  Seg_Buf[3*i+1] = Event_Time[i] % 10;
 270   4                }         
 271   3              break;
 272   3            }
 273   2          break;
 274   2        }
 275   1      }
 276          
 277          /* 其他显示函数 */
 278          void Led_Proc()
 279          {
 280   1        
 281   1      }
 282          
 283          /* 定时器0初始化函数 */
 284          void Timer0Init(void)   //0毫秒@12.000MHz
 285          {
 286   1        AUXR &= 0x7F;   //定时器时钟12T模式
 287   1        TMOD &= 0xF0;   //设置定时器模式
 288   1        TMOD |= 0x04;   //设置计数模式
 289   1        TL0 = 0x00;   //设置定时初值
 290   1        TH0 = 0x00;   //设置定时初值
 291   1        TF0 = 0;    //清除TF0标志
 292   1        TR0 = 1;    //定时器0开始计时
 293   1      }
 294          
 295          /* 定时器2初始化函数 */
 296          void Timer2Init(void)   //1毫秒@12.000MHz
 297          {
 298   1        AUXR &= 0xFB;   //定时器时钟12T模式
 299   1        T2L = 0x18;   //设置定时初值
 300   1        T2H = 0xFC;   //设置定时初值
 301   1        AUXR |= 0x10;   //定时器2开始计时
C51 COMPILER V9.54   MAIN                                                                  04/02/2023 17:20:47 PAGE 6   

 302   1        IE2  |=  0x04;    //允许定时器2中断
 303   1        EA = 1;         //总中断打开
 304   1      }
 305          
 306          /* 定时器2中断服务函数 */
 307          void Timer2Server() interrupt 12
 308          {  
 309   1        if(++Key_Slow_Down == 10) Key_Slow_Down = 0;//键盘减速专用
 310   1        if(++Seg_Slow_Down == 500) Seg_Slow_Down = 0;//数码管减速专用
 311   1        if(++Seg_Pos == 8) Seg_Pos = 0;//数码管显示专用
 312   1        Seg_Disp(Seg_Pos,Seg_Buf[Seg_Pos],Seg_Point[Seg_Pos]);
 313   1        Led_Disp(Seg_Pos,ucLed[Seg_Pos]);
 314   1        
 315   1        if(++Timer_1000Ms == 1000)
 316   1        {
 317   2          TR0 = 0;
 318   2          Timer_1000Ms = 0;
 319   2          Freq = TH0 << 8 | TL0;
 320   2          TH0 = TL0 = 0;
 321   2          TR0 = 1;
 322   2        }
 323   1      }
 324          
 325          /* Main */
 326          void main()
 327          {
 328   1        System_Init();
 329   1        EEPROM_Read(Voltage_Val_Disp,0,2);//上电读取初始阈值
 330   1        Voltage_Val_Ctrol[0] = Voltage_Val_Disp[0];
 331   1        Voltage_Val_Ctrol[1] = Voltage_Val_Disp[1]; 
 332   1        EEPROM_Read(&Event_Type,3,1);//读取类型变量
 333   1        EEPROM_Read(Event_Time,8,3);//读取事件变量
 334   1        Set_Rtc(ucRtc);//上电设置初始时钟数据
 335   1        Timer2Init();
 336   1        Timer0Init();
 337   1        while (1)
 338   1        {
 339   2          Key_Proc();
 340   2          Seg_Proc();
 341   2          Led_Proc();
 342   2        }
 343   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1684    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     56       1
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      3    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
