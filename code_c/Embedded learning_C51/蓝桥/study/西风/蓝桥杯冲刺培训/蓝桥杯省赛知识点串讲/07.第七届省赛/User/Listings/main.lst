C51 COMPILER V9.54   MAIN                                                                  02/12/2023 12:24:42 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\Driver) DEBUG OBJECTEXTEND PRI
                    -NT(.\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          /* 头文件声明区 */
   2          #include <STC15F2K60S2.H>//单片机寄存器专用头文件
   3          #include <Init.h>//初始化底层驱动专用头文件
   4          #include <Led.h>//Led底层驱动专用头文件
   5          #include <Key.h>//按键底层驱动专用头文件
   6          #include <Seg.h>//数码管底层驱动专用头文件
   7          #include "onewire.h"//温度底层驱动专用头文件
   8          
   9          /* 变量声明区 */
  10          unsigned char Key_Val,Key_Down,Key_Old,Key_Up;//按键专用变量
  11          unsigned char Key_Slow_Down;//按键减速专用变量
  12          unsigned char Seg_Buf[8] = {10,10,10,10,10,10,10,10};//数码管显示数据存放数组
  13          unsigned char Seg_Point[8] = {0,0,0,0,0,0,0,0};//数码管小数点数据存放数组
  14          unsigned char Seg_Pos;//数码管扫描专用变量
  15          unsigned int Seg_Slow_Down;//数码管减速专用变量
  16          unsigned char ucLed[8] = {0,0,0,0,0,0,0,0};//Led显示数据存放数组
  17          unsigned char Wind_Mode;//风速模式 0-睡眠风 1-自然风 2-常风
  18          unsigned char Work_Time;//剩余工作时间变量
  19          unsigned char Time_Data[3] = {0,60,120};//时间设置数据储存数组
  20          unsigned char Time_Data_Index;//时间设置数组指针
  21          unsigned int Timer_1000Ms;//一千毫秒计时变量
  22          unsigned char Temperature;//实时温度变量
  23          unsigned char PWM_Count;//PWM计数变量
  24          unsigned char PWM_Level;//PWM等级变量
  25          bit Seg_Disp_Mode;//数码管显示模式变量 0-工作状态 1-温度模式
  26          
  27          /* 键盘处理函数 */
  28          void Key_Proc()
  29          {
  30   1        if(Key_Slow_Down) return;
  31   1        Key_Slow_Down = 1;//键盘减速程序
  32   1      
  33   1        Key_Val = Key_Read();//实时读取键码值
  34   1        Key_Down = Key_Val & (Key_Old ^ Key_Val);//捕捉按键下降沿
  35   1        Key_Up = ~Key_Val & (Key_Old ^ Key_Val);//捕捉按键上降沿
  36   1        Key_Old = Key_Val;//辅助扫描变量
  37   1      
  38   1        switch(Key_Down)
  39   1        {
  40   2          case 4://工作模式切换按键
  41   2            if(Seg_Disp_Mode == 0) //处于工作模式状态
  42   2            {
  43   3              if(++Wind_Mode == 3) //循环切换三种风速模式
  44   3                Wind_Mode = 0;
  45   3            }
  46   2          break;
  47   2          case 5://定时设置按键
  48   2            if(Seg_Disp_Mode == 0) //处于工作模式状态
  49   2            {
  50   3              if(++Time_Data_Index == 3) //切换索引值
  51   3                Time_Data_Index = 0;
  52   3              Work_Time = Time_Data[Time_Data_Index];//重新设置时间
  53   3            }
  54   2          break;
C51 COMPILER V9.54   MAIN                                                                  02/12/2023 12:24:42 PAGE 2   

  55   2          case 6://系统停止按键
  56   2            if(Seg_Disp_Mode == 0) //处于工作模式状态
  57   2              Work_Time = 0;//复位计时值
  58   2          break;
  59   2          case 7://室温功能按键
  60   2            Seg_Disp_Mode ^= 1;//切换数码管显示模式
  61   2          break;
  62   2        }
  63   1      }
  64          
  65          /* 信息处理函数 */
  66          void Seg_Proc()
  67          {
  68   1        if(Seg_Slow_Down) return;
  69   1        Seg_Slow_Down = 1;//数码管减速程序
  70   1      
  71   1        /* 信息获取区域 */
  72   1        Temperature = rd_temperature();//实时读取温度
  73   1        
  74   1        /* 数据显示区域 */
  75   1        if(Seg_Disp_Mode == 0) //处于工作状态
  76   1        {
  77   2          Seg_Buf[0] = Seg_Buf[2] = 11;// -
  78   2          Seg_Buf[1] = Wind_Mode + 1;
  79   2          Seg_Buf[4] = 0;
  80   2          Seg_Buf[5] = Work_Time / 100 % 10;
  81   2          Seg_Buf[6] = Work_Time / 10 % 10;
  82   2          Seg_Buf[7] = Work_Time % 10;
  83   2        }
  84   1        else //处于温度模式
  85   1        {
  86   2          Seg_Buf[0] = Seg_Buf[2] = 11;// -
  87   2          Seg_Buf[1] = 4;
  88   2          Seg_Buf[4] = 10;
  89   2          Seg_Buf[5] = Temperature / 10 % 10;
  90   2          Seg_Buf[6] = Temperature % 10;
  91   2          Seg_Buf[7] = 12;
  92   2        }
  93   1      }
  94          
  95          /* 其他显示函数 */
  96          void Led_Proc()
  97          {
  98   1        unsigned char i;//For循环专用变量
  99   1        for(i=0;i<3;i++) //互斥点亮
 100   1          ucLed[i] = (i == Wind_Mode) * Work_Time;
 101   1      }
 102          
 103          /* 定时器0中断初始化函数 */
 104          void Timer0Init(void)   //1毫秒@12.000MHz
 105          {
 106   1        AUXR &= 0x7F;   //定时器时钟12T模式
 107   1        TMOD &= 0xF0;   //设置定时器模式
 108   1        TL0 = 0x18;   //设置定时初始值
 109   1        TH0 = 0xFC;   //设置定时初始值
 110   1        TF0 = 0;    //清除TF0标志
 111   1        TR0 = 1;    //定时器0开始计时
 112   1        ET0 = 1;    //定时器中断0打开
 113   1        EA = 1;     //总中断打开
 114   1      }
 115          
 116          /* 定时器1中断初始化函数 */
C51 COMPILER V9.54   MAIN                                                                  02/12/2023 12:24:42 PAGE 3   

 117          void Timer1Init(void)   //100微秒@12.000MHz
 118          {
 119   1        AUXR &= 0xBF;   //定时器时钟12T模式
 120   1        TMOD &= 0x0F;   //设置定时器模式
 121   1        TL1 = 0x9C;   //设置定时初始值
 122   1        TH1 = 0xFF;   //设置定时初始值
 123   1        TF1 = 0;    //清除TF1标志
 124   1        TR1 = 1;    //定时器1开始计时
 125   1        ET1 = 1;
 126   1      }
 127          
 128          /* 定时器0中断服务函数 */
 129          void Timer0Server() interrupt 1
 130          {  
 131   1        if(++Key_Slow_Down == 10) Key_Slow_Down = 0;//键盘减速专用
 132   1        if(++Seg_Slow_Down == 500) Seg_Slow_Down = 0;//数码管减速专用
 133   1        if(++Seg_Pos == 8) Seg_Pos = 0;//数码管显示专用
 134   1        Seg_Disp(Seg_Pos,Seg_Buf[Seg_Pos],Seg_Point[Seg_Pos]);
 135   1        Led_Disp(Seg_Pos,ucLed[Seg_Pos]);
 136   1        
 137   1        if(Work_Time != 0) //当计时值不为0时
 138   1        {
 139   2          if(++Timer_1000Ms == 1000) //1000毫秒触发一次
 140   2          {
 141   3            Timer_1000Ms = 0;
 142   3            Work_Time--;
 143   3          }
 144   2        }
 145   1      }
 146          
 147          /* 定时器1中断服务函数 */
 148          void Timer1Server() interrupt 3
 149          {
 150   1        //信号频率为1KMhz 所对应周期为1毫秒 故需要生成更短时间的定时器中断实现PWM
 151   1        if(Work_Time != 0) //当计时值不为0时
 152   1        {
 153   2          if(++PWM_Count == 10) PWM_Count = 0;//定义一个周期为一毫秒
 154   2          PWM_Level = (3 * Wind_Mode) + ((Wind_Mode + 1) % 2);//根据风速调整占空比
 155   2          if(PWM_Count >= PWM_Level)
 156   2            P34 = 1;
 157   2          else
 158   2            P34 = 0;
 159   2        }
 160   1      }
 161          
 162          /* Main */
 163          void main()
 164          {
 165   1        System_Init();
 166   1        Timer0Init();
 167   1        Timer1Init();
 168   1        while (1)
 169   1        {
 170   2          Key_Proc();
 171   2          Seg_Proc();
 172   2          Led_Proc();
 173   2        }
 174   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    522    ----
C51 COMPILER V9.54   MAIN                                                                  02/12/2023 12:24:42 PAGE 4   

   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     43    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
