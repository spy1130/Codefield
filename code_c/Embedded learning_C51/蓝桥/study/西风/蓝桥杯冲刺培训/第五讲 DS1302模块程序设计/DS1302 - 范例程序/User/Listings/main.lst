C51 COMPILER V9.54   MAIN                                                                  12/17/2022 17:25:29 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\Driver) DEBUG OBJECTEXTEND PRI
                    -NT(.\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          /* å¤´æ–‡ä»¶å£°æ˜åŒº */
   2          #include <STC15F2K60S2.H>//å•ç‰‡æœºå¯„å­˜å™¨ä¸“ç”¨å¤´æ–‡ä»¶
   3          #include <Init.h>//åˆå§‹åŒ–åº•å±‚é©±åŠ¨ä¸“ç”¨å¤´æ–‡ä»¶
   4          #include <Led.h>//Ledåº•å±‚é©±åŠ¨ä¸“ç”¨å¤´æ–‡ä»¶
   5          #include <Key.h>//æŒ‰é”®åº•å±‚é©±åŠ¨ä¸“ç”¨å¤´æ–‡ä»¶
   6          #include <Seg.h>//æ•°ç ç®¡åº•å±‚é©±åŠ¨ä¸“ç”¨å¤´æ–‡ä»¶
   7          #include "ds1302.h"//DS1302åº•å±‚é©±åŠ¨ä¸“ç”¨å¤´æ–‡ä»¶
   8          #include <string.h>//memcpyå‡½æ•°ä¸“ç”¨å¤´æ–‡ä»¶
   9          
  10          /* å˜é‡å£°æ˜åŒº */
  11          unsigned char Key_Val,Key_Down,Key_Old,Key_Up;//æŒ‰é”®ä¸“ç”¨å˜é‡
  12          unsigned char Key_Slow_Down;//æŒ‰é”®å‡é€Ÿä¸“ç”¨å˜é‡
  13          unsigned char Seg_Buf[8] = {10,10,10,10,10,10,10,10};//æ•°ç ç®¡æ˜¾ç¤ºæ•°æ®å­˜æ”¾æ•°ç»„
  14          unsigned char Seg_Point[8] = {0,0,0,0,0,0,0,0};//æ•°ç ç®¡å°æ•°ç‚¹æ•°æ®å­˜æ”¾æ•°ç»„
  15          unsigned char Seg_Pos;//æ•°ç ç®¡æ‰«æä¸“ç”¨å˜é‡
  16          unsigned int Seg_Slow_Down;//æ•°ç ç®¡å‡é€Ÿä¸“ç”¨å˜é‡
  17          unsigned char ucLed[8] = {0,0,0,0,0,0,0,0};//Ledæ˜¾ç¤ºæ•°æ®å­˜æ”¾æ•°ç»„
  18          unsigned char Seg_Disp_Mode;//æ•°ç ç®¡æ˜¾ç¤ºæ¨¡å¼å˜é‡ 0-æ—¶é’Ÿæ˜¾ç¤º 1-é—¹é’Ÿæ˜¾ç¤º 2-æ—¥æœŸæ˜¾ç¤º 3-æ
             -—¶é’Ÿè®¾ç½® 4-é—¹é’Ÿè®¾ç½® 5-æ—¥æœŸè®¾ç½®
  19          unsigned char ucRtc[3] = {0x23,0x59,0x55};//æ—¶é’Ÿæ•°æ®å­˜æ”¾æ•°ç»„ ä¸Šç”µåˆå§‹åŒ–æ—¶é—´ 23:59:55
  20          unsigned char ucDate[3] = {0x22,0x12,0x12};//æ—¥æœŸæ•°æ®å­˜æ”¾æ•°ç»„ ä¸Šç”µåˆå§‹åŒ–æ—¥æœŸ 22-12-12
  21          unsigned char ucRtc_Set[6];//æ—¶é’Ÿæ•°æ®è®¾ç½®æ•°ç»„ å°†æ—¶åˆ†ç§’çš„åä½å’Œä¸ªä½æ‹†åˆ†æˆå…­ä¸ªæ•°å­— 
             -ä¾¿äºç›´æ¥è¾“å…¥åçš„æ›¿æ¢
  22          unsigned char ucDate_Set[6];//æ—¥æœŸæ•°æ®è®¾ç½®æ•°ç»„
  23          unsigned char Alarm_Set[3][6];//é—¹é’Ÿæ•°æ®è®¾ç½®æ•°ç»„
  24          unsigned char Set_Index;//è®¾ç½®æ•°ç»„æŒ‡é’ˆ ç”¨äºåˆ¤æ–­å½“å‰è¾“å…¥çš„ä½æ•°
  25          unsigned int Timer_500Ms;//äº”ç™¾æ¯«ç§’è®¡æ—¶å˜é‡
  26          bit Seg_Star_Flag;//æ•°ç ç®¡é—ªçƒæ ‡å¿—ä½
  27          
  28          
  29          /* æ–¹æ³•ä¸€ ç»“æ„ä½“ */
  30          //struct Alarm//å®šä¹‰é—¹é’Ÿç»“æ„ä½“
  31          //{
  32          //  unsigned char Hour;
  33          //  unsigned char Min;
  34          //  unsigned char Sec;
  35          //};
  36          //struct Alarm Alarm_Dat[3] = //å®šä¹‰é—¹é’Ÿæ•°æ®
  37          //{
  38          //  {0x00,0x00,0x00},
  39          //  {0x00,0x01,0x00},
  40          //  {0xbb,0xbb,0xbb}
  41          //};
  42          
  43          /* æ–¹æ³•äºŒ äºŒç»´æ•°ç»„ */
  44          unsigned char Alarm_Dat[3][3] = 
  45          {
  46            {0x00,0x00,0x00},
  47            {0x00,0x01,0x00},
  48            {0xbb,0xbb,0xbb}
  49          };
  50          
  51          unsigned char Alarm_Dat_Index;//é—¹é’Ÿæ•°ç»„æŒ‡é’ˆ ç”¨äºè¡¨ç¤ºé—¹é’Ÿç¼–å·
  52          
C51 COMPILER V9.54   MAIN                                                                  12/17/2022 17:25:29 PAGE 2   

  53          /* æ•°ç»„æ•°æ®è¯»å–å‡½æ•° */
  54          void Dat_To_Set(unsigned char* Dat,unsigned char* Set)
  55          {
  56   1        unsigned char i;//ç”¨äºForå¾ªç¯
  57   1        for(i=0;i<3;i++)
  58   1        {
  59   2          Set[2*i] = Dat[i] / 16;
  60   2          Set[2*i+1] = Dat[i] % 16;
  61   2        }
  62   1      }
  63          
  64          /* é”®ç›˜å¤„ç†å‡½æ•° */
  65          void Key_Proc()
  66          {
  67   1        unsigned char i,j;//ç”¨äºForå¾ªç¯
  68   1        if(Key_Slow_Down) return;
  69   1        Key_Slow_Down = 1;//é”®ç›˜å‡é€Ÿç¨‹åº
  70   1      
  71   1        Key_Val = Key_Read();//å®æ—¶è¯»å–é”®ç å€¼
  72   1        Key_Down = Key_Val & (Key_Old ^ Key_Val);//æ•æ‰æŒ‰é”®ä¸‹é™æ²¿
  73   1        Key_Up = ~Key_Val & (Key_Old ^ Key_Val);//æ•æ‰æŒ‰é”®ä¸Šé™æ²¿
  74   1        Key_Old = Key_Val;//è¾…åŠ©æ‰«æå˜é‡
  75   1      
  76   1        /* é”®ç›˜è¾“å…¥åŒºåŸŸ */
  77   1        if(Key_Down >= 4 && Key_Down <= 13)
  78   1        {
  79   2          switch(Seg_Disp_Mode)
  80   2          {
  81   3            case 3://æ—¶é’Ÿè®¾ç½®
  82   3              ucRtc_Set[Set_Index] = Key_Down - 4;
  83   3            break;
  84   3            case 4://é—¹é’Ÿè®¾ç½®
  85   3              Alarm_Set[Alarm_Dat_Index][Set_Index] = Key_Down - 4;
  86   3            break;
  87   3            case 5://æ—¥æœŸè®¾ç½®
  88   3              ucDate_Set[Set_Index] = Key_Down - 4;
  89   3            break;
  90   3          }
  91   2          //if(++Set_Index == 6) Set_Index = 0;//å¾ªç¯è¾“å…¥
  92   2          Set_Index = (Set_Index + 1) % 6;//å¾ªç¯é€šç”¨è¡¨è¾¾å¼ï¼šï¼ˆå˜é‡-å¾ªç¯èµ·ç‚¹+1ï¼‰%ï¼ˆå¾ªç¯ç»ˆç‚¹-å¾
             -ªç¯èµ·ç‚¹+1ï¼‰ + å¾ªç¯èµ·ç‚¹
  93   2        }
  94   1        
  95   1        switch(Key_Down)
  96   1        {
  97   2          case 14://ç•Œé¢åˆ‡æ¢æŒ‰é”®
  98   2            if(Seg_Disp_Mode < 3) //åœ¨éå‚æ•°è®¾ç½®çŠ¶æ€ä¸‹ä½¿èƒ½
  99   2            {
 100   3              if(++Seg_Disp_Mode == 3) //åœ¨0-2ä¹‹é—´å¾ªç¯åˆ‡æ¢
 101   3                Seg_Disp_Mode = 0;
 102   3            }
 103   2          break;
 104   2          case 15://å‚æ•°è®¾ç½®æŒ‰é”®
 105   2            if(Seg_Disp_Mode < 3) //åœ¨éå‚æ•°è®¾ç½®çŠ¶æ€
 106   2            {
 107   3              Seg_Disp_Mode += 3;//åˆ‡æ¢åˆ°å¯¹åº”çš„è®¾ç½®ç•Œé¢å†…
 108   3              switch(Seg_Disp_Mode)
 109   3              {
 110   4                case 3://åˆ‡æ¢åˆ°æ—¶é’Ÿè®¾ç½®ç•Œé¢
 111   4      //            for(i=0;i<3;i++)//å°†å½“å‰æ—¶é’Ÿæ•°æ®ç»™è®¾ç½®æ•°ç»„
 112   4      //            {
 113   4      //              ucRtc_Set[2*i] = ucRtc[i] / 16;
C51 COMPILER V9.54   MAIN                                                                  12/17/2022 17:25:29 PAGE 3   

 114   4      //              ucRtc_Set[2*i+1] = ucRtc[i] % 16;
 115   4      //            }
 116   4                  Dat_To_Set(ucRtc,ucRtc_Set);
 117   4                break;
 118   4                case 4://åˆ‡æ¢åˆ°é—¹é’Ÿè®¾ç½®ç•Œé¢
 119   4                  Alarm_Dat_Index = 0;//é—¹é’ŸæŒ‡é’ˆå¤ä½
 120   4                  for(i=0;i<3;i++)//å°†å½“å‰é—¹é’Ÿæ•°æ®ç»™è®¾ç½®æ•°ç»„
 121   4                  {
 122   5                    Dat_To_Set(Alarm_Dat[i],Alarm_Set[i]);
 123   5      //              for(j=0;j<3;j++)
 124   5      //              {
 125   5      //                Alarm_Set[i][2*j] = Alarm_Dat[i][j] / 16;
 126   5      //                Alarm_Set[i][2*j+1] = Alarm_Dat[i][j] % 16;
 127   5      //              }
 128   5                  }
 129   4                break;  
 130   4                case 5://åˆ‡æ¢åˆ°æ—¥æœŸè®¾ç½®ç•Œé¢
 131   4                  Dat_To_Set(ucDate,ucDate_Set);
 132   4      //            for(i=0;i<3;i++)//å°†å½“å‰æ—¥æœŸæ•°æ®ç»™è®¾ç½®æ•°ç»„
 133   4      //            {
 134   4      //              ucDate_Set[2*i] = ucDate[i] / 16;
 135   4      //              ucDate_Set[2*i+1] = ucDate[i] % 16;
 136   4      //            }
 137   4                break;            
 138   4              }
 139   3            }
 140   2          break;
 141   2          case 17://é—¹é’Ÿåˆ‡æ¢æŒ‰é”®
 142   2            if(Seg_Disp_Mode == 1 || Seg_Disp_Mode == 4) // å¤„äºé—¹é’Ÿæ˜¾ç¤ºç•Œé¢
 143   2            {
 144   3              Set_Index = 0;//æ¯æ¬¡åˆ‡æ¢å°†è¾“å…¥æ ‡å¿—ä½ç½®0
 145   3              if(++Alarm_Dat_Index == 3) //åœ¨0-2ä¹‹é—´å¾ªç¯åˆ‡æ¢
 146   3                Alarm_Dat_Index = 0;        
 147   3            }
 148   2          break;
 149   2        }
 150   1      }
*** WARNING C280 IN LINE 67 OF main.c: 'j': unreferenced local variable
 151          
 152          /* ä¿¡æ¯å¤„ç†å‡½æ•° */
 153          void Seg_Proc()
 154          {
 155   1        unsigned char i;//Forå¾ªç¯ä¸“ç”¨å˜é‡
 156   1        if(Seg_Slow_Down) return;
 157   1        Seg_Slow_Down = 1;//æ•°ç ç®¡å‡é€Ÿç¨‹åº
 158   1        
 159   1        /* ä¿¡æ¯è¯»å–åŒºåŸŸ */
 160   1        Read_Rtc(ucRtc);//è¯»å–å®æ—¶æ—¶é’Ÿæ•°æ®
 161   1        Read_Date(ucDate);//è¯»å–å®æ—¶æ—¥æœŸæ•°æ®
 162   1        
 163   1        /* æ•°æ®å¤„ç†åŒºåŸŸ */
 164   1        switch(Seg_Disp_Mode)
 165   1        {
 166   2          case 0://æ—¶é’Ÿæ˜¾ç¤º
 167   2      //      Seg_Buf[0] = ucRtc[0] / 16;
 168   2      //      Seg_Buf[1] = ucRtc[0] % 16;
 169   2      //      Seg_Buf[3] = ucRtc[1] / 16;
 170   2      //      Seg_Buf[4] = ucRtc[1] % 16;
 171   2      //      Seg_Buf[6] = ucRtc[2] / 16;
 172   2      //      Seg_Buf[7] = ucRtc[2] % 16;   
 173   2      //      Seg_Buf[2] = Seg_Buf[5] = 11;
 174   2            for(i=0;i<3;i++)
C51 COMPILER V9.54   MAIN                                                                  12/17/2022 17:25:29 PAGE 4   

 175   2            {
 176   3              Seg_Buf[3*i] = ucRtc[i] / 16;
 177   3              Seg_Buf[3*i+1] = ucRtc[i] % 16;
 178   3            }
 179   2            Seg_Buf[2] = Seg_Buf[5] = 11;
 180   2          break;
 181   2          case 1://é—¹é’Ÿæ˜¾ç¤º
 182   2      //      Seg_Buf[0] = Alarm_Dat[Alarm_Dat_Index].Hour / 16;
 183   2      //      Seg_Buf[1] = Alarm_Dat[Alarm_Dat_Index].Hour % 16;
 184   2      //      Seg_Buf[3] = Alarm_Dat[Alarm_Dat_Index].Min / 16;
 185   2      //      Seg_Buf[4] = Alarm_Dat[Alarm_Dat_Index].Min % 16;
 186   2      //      Seg_Buf[6] = Alarm_Dat[Alarm_Dat_Index].Sec / 16;
 187   2      //      Seg_Buf[7] = Alarm_Dat[Alarm_Dat_Index].Sec % 16;   
 188   2      //      Seg_Buf[2] = Seg_Buf[5] = 11;
 189   2            for(i=0;i<3;i++)
 190   2            {
 191   3              Seg_Buf[3*i] = Alarm_Dat[Alarm_Dat_Index][i] / 16;
 192   3              Seg_Buf[3*i+1] = Alarm_Dat[Alarm_Dat_Index][i] % 16;
 193   3            }
 194   2            Seg_Buf[2] = Seg_Buf[5] = 11;   
 195   2          break;
 196   2          case 2://æ—¥æœŸæ˜¾ç¤º
 197   2            for(i=0;i<3;i++)
 198   2            {
 199   3              Seg_Buf[3*i] = ucDate[i] / 16;
 200   3              Seg_Buf[3*i+1] = ucDate[i] % 16;
 201   3            }
 202   2            Seg_Buf[2] = Seg_Buf[5] = 11;     
 203   2          break;
 204   2          case 3://æ—¶é’Ÿè®¾ç½®
 205   2            for(i=0;i<3;i++)
 206   2            {
 207   3              Seg_Buf[3*i] = ucRtc_Set[2*i];
 208   3              Seg_Buf[3*i+1] = ucRtc_Set[2*i+1];
 209   3            }
 210   2            Seg_Buf[2] = Seg_Buf[5] = 11;
 211   2            Seg_Buf[3*(Set_Index/2)] = Seg_Star_Flag?ucRtc_Set[2*(Set_Index/2)]:10;
 212   2            Seg_Buf[3*(Set_Index/2)+1] = Seg_Star_Flag?ucRtc_Set[2*(Set_Index/2)+1]:10;
 213   2          break;
 214   2          case 4://é—¹é’Ÿè®¾ç½®
 215   2            for(i=0;i<3;i++)
 216   2            {
 217   3              Seg_Buf[3*i] = Alarm_Set[Alarm_Dat_Index][2*i];
 218   3              Seg_Buf[3*i+1] = Alarm_Set[Alarm_Dat_Index][2*i+1];
 219   3            }
 220   2            Seg_Buf[2] = Seg_Buf[5] = 11;
 221   2            Seg_Buf[3*(Set_Index/2)] = Seg_Star_Flag?Alarm_Set[Alarm_Dat_Index][2*(Set_Index/2)]:10;
 222   2            Seg_Buf[3*(Set_Index/2)+1] = Seg_Star_Flag?Alarm_Set[Alarm_Dat_Index][2*(Set_Index/2)+1]:10;
 223   2          break;
 224   2          case 5://æ—¥æœŸè®¾ç½®
 225   2            for(i=0;i<3;i++)
 226   2            {
 227   3              Seg_Buf[3*i] = ucDate_Set[2*i];
 228   3              Seg_Buf[3*i+1] = ucDate_Set[2*i+1];
 229   3            }
 230   2            Seg_Buf[2] = Seg_Buf[5] = 11;   
 231   2            Seg_Buf[3*(Set_Index/2)] = Seg_Star_Flag?ucDate_Set[2*(Set_Index/2)]:10;
 232   2            Seg_Buf[3*(Set_Index/2)+1] = Seg_Star_Flag?ucDate_Set[2*(Set_Index/2)+1]:10;
 233   2          break;
 234   2        }
 235   1        
 236   1      }
C51 COMPILER V9.54   MAIN                                                                  12/17/2022 17:25:29 PAGE 5   

 237          
 238          
 239          /* å…¶ä»–æ˜¾ç¤ºå‡½æ•° */
 240          void Led_Proc()
 241          {
 242   1        unsigned char i;//Forå¾ªç¯ä¸“ç”¨å˜é‡
 243   1        for(i=1;i<4;i++)//å¸¸ç”¨äº’æ–¥ç‚¹äº®æ€è·¯ åˆ©ç”¨ä½è¿ç®—ç¬¦ æ¡ä»¶æ»¡è¶³æ—¶é»˜è®¤è¿”å›1
 244   1          ucLed[i] = (i == Alarm_Dat_Index + 1) * (Seg_Disp_Mode == 1 || Seg_Disp_Mode == 4);//å¤„äºæ—¶é’Ÿç•Œé¢æ
             -—¶ ç‚¹äº®ç›¸åº”çš„LedæŒ‡ç¤ºç¯
 245   1      }
 246          
 247          /* å®šæ—¶å™¨0ä¸­æ–­åˆå§‹åŒ–å‡½æ•° */
 248          void Timer0Init(void)   //1æ¯«ç§’@12.000MHz
 249          {
 250   1        AUXR &= 0x7F;   //å®šæ—¶å™¨æ—¶é’Ÿ12Tæ¨¡å¼
 251   1        TMOD &= 0xF0;   //è®¾ç½®å®šæ—¶å™¨æ¨¡å¼
 252   1        TL0 = 0x18;   //è®¾ç½®å®šæ—¶åˆå§‹å€¼
 253   1        TH0 = 0xFC;   //è®¾ç½®å®šæ—¶åˆå§‹å€¼
 254   1        TF0 = 0;    //æ¸…é™¤TF0æ ‡å¿—
 255   1        TR0 = 1;    //å®šæ—¶å™¨0å¼€å§‹è®¡æ—¶
 256   1        ET0 = 1;    //å®šæ—¶å™¨ä¸­æ–­0æ‰“å¼€
 257   1        EA = 1;     //æ€»ä¸­æ–­æ‰“å¼€
 258   1      }
 259          
 260          /* å®šæ—¶å™¨0ä¸­æ–­æœåŠ¡å‡½æ•° */
 261          void Timer0Server() interrupt 1
 262          {  
 263   1        if(++Key_Slow_Down == 10) Key_Slow_Down = 0;//é”®ç›˜å‡é€Ÿä¸“ç”¨
 264   1        if(++Seg_Slow_Down == 100) Seg_Slow_Down = 0;//æ•°ç ç®¡å‡é€Ÿä¸“ç”¨
 265   1        if(++Seg_Pos == 8) Seg_Pos = 0;//æ•°ç ç®¡æ˜¾ç¤ºä¸“ç”¨
 266   1        Seg_Disp(Seg_Pos,Seg_Buf[Seg_Pos],Seg_Point[Seg_Pos]);
 267   1        Led_Disp(Seg_Pos,ucLed[Seg_Pos]);
 268   1        if(++Timer_500Ms == 500)
 269   1        {
 270   2          Timer_500Ms = 0;//è®¡æ—¶å€¼å¤ä½
 271   2          Seg_Star_Flag ^= 1;//æ ‡å¿—ä½å–å
 272   2        }
 273   1      }
 274          
 275          /* Main */
 276          void main()
 277          {
 278   1        System_Init();
 279   1        Timer0Init();
 280   1        Set_Rtc(ucRtc);//è®¾ç½®ä¸Šç”µåˆå§‹åŒ–æ—¶é—´
 281   1        Set_Date(ucDate);//è®¾ç½®ä¸Šç”µåˆå§‹åŒ–æ—¥æœŸ
 282   1        while (1)
 283   1        {
 284   2          Key_Proc();
 285   2          Seg_Proc();
 286   2          Led_Proc();
 287   2        }
 288   1      }
 289          
 290          
 291          //if (input == 1)
 292          //    A = (Key_Down << 4) | (A & 0xF)
 293          //else 
 294          //    A = (A & 0xF0) | Key_Down


MODULE INFORMATION:   STATIC OVERLAYABLE
C51 COMPILER V9.54   MAIN                                                                  12/17/2022 17:25:29 PAGE 6   

   CODE SIZE        =   1261    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     82       9
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
