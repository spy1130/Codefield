C51 COMPILER V9.54   MAIN                                                                  02/10/2023 19:55:40 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\Driver) DEBUG OBJECTEXTEND PRI
                    -NT(.\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          /* 头文件声明区 */
   2          #include <STC15F2K60S2.H>//单片机寄存器专用头文件
   3          #include <Init.h>//初始化底层驱动专用头文件
   4          #include <Led.h>//Led底层驱动专用头文件
   5          #include <Key.h>//按键底层驱动专用头文件
   6          #include <Seg.h>//数码管底层驱动专用头文件
   7          #include "ds1302.h" 
   8          
   9          
  10          /* 变量声明区 */
  11          unsigned char Key_Val,Key_Down,Key_Old,Key_Up;//按键专用变量
  12          unsigned char Key_Slow_Down;//按键减速专用变量
  13          unsigned char Seg_Buf[8] = {10,10,10,10,10,10,10,10};//数码管显示数据存放数组
  14          unsigned char Seg_Point[8] = {0,0,0,0,0,0,0,0};//数码管小数点数据存放数组
  15          unsigned char Seg_Pos;//数码管扫描专用变量
  16          unsigned int Seg_Slow_Down;//数码管减速专用变量
  17          unsigned char ucLed[8] = {0,0,0,0,0,0,0,0};//Led显示数据存放数组
  18          bit Seg_Disp_Mode;//数码管显示模式变量 0-时间相关 1-温度相关
  19          unsigned char ucRtc[3] = {0x23,0x59,0x50};
  20          unsigned char ucRtc_Set[3] = {0x23,0x59,0x50};
  21          unsigned char Alarm[3] = {0x00,0x00,0x00};
  22          unsigned char Alarm_Set[3] = {0x00,0x00,0x00};
  23          unsigned char ucRtc_Index;
  24          unsigned int Timer_500Ms;
  25          bit Seg_Star_Flag;
  26          bit Beep_Flag;
  27          unsigned char Timer_100Ms;
  28          bit Led_Star_Flag;
  29          unsigned char* Data_Flag[3] = {ucRtc,ucRtc_Set,Alarm_Set};
  30          unsigned char Seg_Index;//时间相关显示内容 0-时钟显示 1-时钟设置 2-闹钟设置
  31          
  32          /* 键盘处理函数 */
  33          void Key_Proc()
  34          {
  35   1        unsigned char i;
  36   1        if(Key_Slow_Down) return;
  37   1        Key_Slow_Down = 1;//键盘减速程序
  38   1      
  39   1        Key_Val = Key_Read();//实时读取键码值
  40   1        Key_Down = Key_Val & (Key_Old ^ Key_Val);//捕捉按键下降沿
  41   1        Key_Up = ~Key_Val & (Key_Old ^ Key_Val);//捕捉按键上降沿
  42   1        Key_Old = Key_Val;//辅助扫描变量
  43   1      
  44   1        if(Beep_Flag == 1)
  45   1        {
  46   2          if(Key_Down != 0)
  47   2            Beep_Flag = 0;
  48   2        }
  49   1        
  50   1        switch(Key_Down)
  51   1        {
  52   2          case 7:
  53   2            if(Seg_Disp_Mode == 0) //时钟相关
  54   2            {
C51 COMPILER V9.54   MAIN                                                                  02/10/2023 19:55:40 PAGE 2   

  55   3              if(Seg_Index == 0)
  56   3              {
  57   4                for(i=0;i<3;i++)
  58   4                  ucRtc_Set[i] = ucRtc[i];
  59   4                Seg_Index = 1;
  60   4              }
  61   3              else if(Seg_Index == 1)
  62   3              {
  63   4                if(++ucRtc_Index == 3)
  64   4                {
  65   5                  Set_Rtc(ucRtc_Set);
  66   5                  ucRtc_Index = 0;
  67   5                  Seg_Index = 0;
  68   5                }
  69   4              }
  70   3            }
  71   2          break;
  72   2          case 5:
  73   2            if(Seg_Disp_Mode == 0) //时钟相关
  74   2            {
  75   3      //        if(Seg_Index == 1) //设置时钟
  76   3      //        {
  77   3      //          ucRtc_Set[ucRtc_Index]++;
  78   3      //          if(ucRtc_Set[ucRtc_Index] % 16 == 0x0a)
  79   3      //            ucRtc_Set[ucRtc_Index] += 6;
  80   3      //          if(ucRtc_Set[ucRtc_Index] == (ucRtc_Index?0x60:0x24))
  81   3      //            ucRtc_Set[ucRtc_Index] = (ucRtc_Index?0x59:0x23);
  82   3      //        }
  83   3              Data_Flag[Seg_Index][ucRtc_Index]++;
  84   3              if(Data_Flag[Seg_Index][ucRtc_Index] % 16 == 0x0a)
  85   3                Data_Flag[Seg_Index][ucRtc_Index] += 6;
  86   3              if(Data_Flag[Seg_Index][ucRtc_Index] == (ucRtc_Index?0x60:0x24))
  87   3                Data_Flag[Seg_Index][ucRtc_Index] = (ucRtc_Index?0x59:0x23);  
  88   3            }
  89   2          break;
  90   2          case 4:
  91   2            if(Seg_Disp_Mode == 0) //时钟相关
  92   2            {
  93   3      //        if(Seg_Index == 1) //设置时钟
  94   3      //        {
  95   3      //          ucRtc_Set[ucRtc_Index]--;
  96   3      //          if(ucRtc_Set[ucRtc_Index] % 16 == 0x0f)
  97   3      //            ucRtc_Set[ucRtc_Index] -= 6;
  98   3      //          if(ucRtc_Set[ucRtc_Index] == 0xf9)
  99   3      //            ucRtc_Set[ucRtc_Index] = 0;
 100   3      //        }
 101   3              Data_Flag[Seg_Index][ucRtc_Index]--;
 102   3              if(Data_Flag[Seg_Index][ucRtc_Index] % 16 == 0x0f)
 103   3                Data_Flag[Seg_Index][ucRtc_Index] -= 6;
 104   3              if(Data_Flag[Seg_Index][ucRtc_Index] == 0xf9)
 105   3                Data_Flag[Seg_Index][ucRtc_Index] = 0;        
 106   3            }     
 107   2          break;
 108   2          case 6:
 109   2            if(Seg_Disp_Mode == 0) //时钟相关
 110   2            {
 111   3              if(Seg_Index == 0)
 112   3                Seg_Index = 2;
 113   3              else if(Seg_Index == 2)
 114   3              {
 115   4                if(++ucRtc_Index == 3)
 116   4                {
C51 COMPILER V9.54   MAIN                                                                  02/10/2023 19:55:40 PAGE 3   

 117   5                  for(i=0;i<3;i++)
 118   5                    Alarm[i] = Alarm_Set[i];
 119   5                  ucRtc_Index = 0;
 120   5                  Seg_Index = 0;
 121   5                }
 122   4              }
 123   3            }
 124   2          break;
 125   2        }
 126   1      }
 127          
 128          /* 信息处理函数 */
 129          void Seg_Proc()
 130          {
 131   1        unsigned char i;
 132   1        if(Seg_Slow_Down) return;
 133   1        Seg_Slow_Down = 1;//数码管减速程序
 134   1      
 135   1        
 136   1        /* 信息读取区域 */
 137   1        Read_Rtc(ucRtc);
 138   1        
 139   1        /* 数据显示区域 */
 140   1        if(Seg_Disp_Mode == 0) //时钟
 141   1        {
 142   2      //    switch(Seg_Index)
 143   2      //    {
 144   2      //      case 0://时钟显示
 145   2      //        Seg_Buf[2] = Seg_Buf[5] = 11;
 146   2      //        for(i=0;i<3;i++)
 147   2      //        {
 148   2      //          Seg_Buf[3*i] = ucRtc[i] / 16;
 149   2      //          Seg_Buf[3*i+1] = ucRtc[i] % 16;
 150   2      //        }
 151   2      //      break;
 152   2      //      case 1://时钟设置
 153   2      //        Seg_Buf[2] = Seg_Buf[5] = 11;
 154   2      //        for(i=0;i<3;i++)
 155   2      //        {
 156   2      //          Seg_Buf[3*i] = ucRtc_Set[i] / 16;
 157   2      //          Seg_Buf[3*i+1] = ucRtc_Set[i] % 16;
 158   2      //        }
 159   2      //        Seg_Buf[3*ucRtc_Index] = Seg_Star_Flag?10:ucRtc_Set[ucRtc_Index] / 16;
 160   2      //        Seg_Buf[3*ucRtc_Index+1] = Seg_Star_Flag?10:ucRtc_Set[ucRtc_Index] % 16;
 161   2      //      break;
 162   2              Seg_Buf[2] = Seg_Buf[5] = 11;
 163   2              for(i=0;i<3;i++)
 164   2              {
 165   3                Seg_Buf[3*i] = Data_Flag[Seg_Index][i] / 16;
 166   3                Seg_Buf[3*i+1] = Data_Flag[Seg_Index][i] % 16;
 167   3              }   
 168   2              if(Seg_Index > 0)
 169   2              {
 170   3                Seg_Buf[3*ucRtc_Index] = Seg_Star_Flag?10:Data_Flag[Seg_Index][ucRtc_Index] / 16;
 171   3                Seg_Buf[3*ucRtc_Index+1] = Seg_Star_Flag?10:Data_Flag[Seg_Index][ucRtc_Index] % 16;
 172   3              }
 173   2          }
 174   1      }
 175          
 176          /* 其他显示函数 */
 177          void Led_Proc()
 178          {
C51 COMPILER V9.54   MAIN                                                                  02/10/2023 19:55:40 PAGE 4   

 179   1        if(Alarm[0] == ucRtc[0] && Alarm[1] == ucRtc[1] && Alarm[2] == ucRtc[2])
 180   1          Beep_Flag = 1;
 181   1        if((ucRtc[2] % 16) == (Alarm[2] % 16 + 5))
 182   1          Beep_Flag = 0;
 183   1        ucLed[0] = Led_Star_Flag & Beep_Flag;
 184   1      }
 185          
 186          /* 定时器0中断初始化函数 */
 187          void Timer0Init(void)   //1毫秒@12.000MHz
 188          {
 189   1        AUXR &= 0x7F;   //定时器时钟12T模式
 190   1        TMOD &= 0xF0;   //设置定时器模式
 191   1        TL0 = 0x18;   //设置定时初始值
 192   1        TH0 = 0xFC;   //设置定时初始值
 193   1        TF0 = 0;    //清除TF0标志
 194   1        TR0 = 1;    //定时器0开始计时
 195   1        ET0 = 1;    //定时器中断0打开
 196   1        EA = 1;     //总中断打开
 197   1      }
 198          
 199          /* 定时器0中断服务函数 */
 200          void Timer0Server() interrupt 1
 201          {  
 202   1        if(++Key_Slow_Down == 10) Key_Slow_Down = 0;//键盘减速专用
 203   1        if(++Seg_Slow_Down == 200) Seg_Slow_Down = 0;//数码管减速专用
 204   1        if(++Seg_Pos == 8) Seg_Pos = 0;//数码管显示专用
 205   1        Seg_Disp(Seg_Pos,Seg_Buf[Seg_Pos],Seg_Point[Seg_Pos]);
 206   1        Led_Disp(Seg_Pos,ucLed[Seg_Pos]);
 207   1        
 208   1        if(++Timer_500Ms == 500)
 209   1        {
 210   2          Timer_500Ms = 0;
 211   2          Seg_Star_Flag ^= 1;
 212   2        }
 213   1        
 214   1        if(++Timer_100Ms == 100)
 215   1        {
 216   2          Timer_100Ms = 0;
 217   2          Led_Star_Flag ^= 1;
 218   2        }
 219   1      }
 220          
 221          /* Main */
 222          void main()
 223          {
 224   1        Set_Rtc(ucRtc);
 225   1        System_Init();
 226   1        Timer0Init();
 227   1        while (1)
 228   1        {
 229   2          Key_Proc();
 230   2          Seg_Proc();
 231   2          Led_Proc();
 232   2        }
 233   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1006    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
C51 COMPILER V9.54   MAIN                                                                  02/10/2023 19:55:40 PAGE 5   

   DATA SIZE        =     58       1
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      4    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
