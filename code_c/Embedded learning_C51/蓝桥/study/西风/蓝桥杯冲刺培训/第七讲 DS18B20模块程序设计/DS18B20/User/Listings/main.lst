C51 COMPILER V9.54   MAIN                                                                  01/06/2023 20:24:00 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\Driver) DEBUG OBJECTEXTEND PRI
                    -NT(.\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          /* 头文件声明区域 */
   2          #include <STC15F2K60S2.H>//15单片机寄存器专属头文件
   3          #include <Key.h>//按键底层专属头文件
   4          #include <Seg.h>//数码管底层专属头文件
   5          #include <Init.h>//初始化底层专属头文件
   6          #include <Led.h>//Led底层专属头文件
   7          #include "onewire.h"//温度读取专属头文件
   8          
   9          /* 变量声明区域 */
  10          unsigned char Key_Slow_Down;//按键减速专用变量
  11          unsigned char Key_Val,Key_Old,Key_Down,Key_Up;//按键扫描专用变量
  12          unsigned int Seg_Slow_Down;//数码管减速专用变量
  13          unsigned char Seg_Pos;//数码管扫描专用变量
  14          unsigned char Seg_Buf[8] = {10,10,10,10,10,10,10,10};//数码管数据显示数组 默认全部熄灭
  15          unsigned char Seg_Point[8] = {0,0,0,0,0,0,0,0};//数码管小数点数据数组 默认熄灭
  16          unsigned char ucLed[8] = {1,1,1,1,1,1,1,1};//Led数据存放数组
  17          unsigned char Seg_Disp_Mode;//数码管显示模式 0-温度显示界面 1-参数设置界面
  18          unsigned char P_Dat[2] = {30,20};//参数数据储存数组
  19          unsigned char P_Ctrol[2] = {30,20};//真实参数控制数组
  20          unsigned char P_Dat_Index;//参数数据数组指针 0-上限 1-下限
  21          unsigned int Timer_500MS;//五百毫秒计时变量
  22          unsigned int Key_Time;//记录按键时间变量
  23          bit Key_Flag;//按键使能标志位
  24          float Temperature;//温度储存变量
  25          bit Seg_Star_Flag;//数码管闪烁标志位
  26          unsigned char Led_Pwm;
  27          unsigned char Level;
  28          
  29          /* 按键处理函数 */
  30          void Key_Proc()
  31          {
  32   1        if(Key_Slow_Down) return;
  33   1        Key_Slow_Down = 1;//按键减速程序
  34   1        
  35   1        Key_Val = Key_Read();//实时读取键码值
  36   1        Key_Down = Key_Val & (Key_Old ^ Key_Val);//读取按键下降沿
  37   1        Key_Up = ~Key_Val & (Key_Old ^ Key_Val);//读取按键上升沿
  38   1        Key_Old = Key_Val;//辅助扫描变量
  39   1        
  40   1        
  41   1        if(Seg_Disp_Mode == 1)
  42   1        {
  43   2          if(Key_Down == 14 || Key_Down == 15)//产生下降沿
  44   2            Key_Flag = 1;//拉高标志位 开始计时
  45   2        }
  46   1        if(Key_Time < 500) //在五百毫秒之内
  47   1        {
  48   2          if(Key_Up == 14) //短按
  49   2          {
  50   3            Key_Flag = Key_Time = 0;
  51   3            if(++P_Dat[P_Dat_Index] == 71)
  52   3              P_Dat[P_Dat_Index] = 10;
  53   3          }
  54   2          if(Key_Up == 15) //短按
C51 COMPILER V9.54   MAIN                                                                  01/06/2023 20:24:00 PAGE 2   

  55   2          {
  56   3            Key_Flag = Key_Time = 0;
  57   3            if(--P_Dat[P_Dat_Index] == 9)
  58   3              P_Dat[P_Dat_Index] = 70;
  59   3          }
  60   2        }
  61   1        else //在五百毫秒之外
  62   1        {
  63   2          if(Key_Old == 14)
  64   2          {
  65   3            if(++P_Dat[P_Dat_Index] == 71)
  66   3              P_Dat[P_Dat_Index] = 10;
  67   3          }
  68   2          if(Key_Old == 15)
  69   2          {
  70   3            if(--P_Dat[P_Dat_Index] == 9)
  71   3              P_Dat[P_Dat_Index] = 70;
  72   3          }
  73   2          if(Key_Up == 14 || Key_Up == 15)
  74   2          {
  75   3            Key_Flag = Key_Time = 0;
  76   3          }
  77   2        }
  78   1        
  79   1        switch(Key_Down)
  80   1        {
  81   2          case 12://界面切换
  82   2            if(++Seg_Disp_Mode == 2) Seg_Disp_Mode = 0;
  83   2            if(Seg_Disp_Mode == 0)//从参数设置界面跳转到温度显示界面
  84   2            {
  85   3              P_Dat_Index = 0;
  86   3              if(P_Dat[0] > P_Dat[1])
  87   3              {
  88   4                P_Ctrol[0] = P_Dat[0];
  89   4                P_Ctrol[1] = P_Dat[1];
  90   4              }
  91   3            }
  92   2            if(Seg_Disp_Mode == 1)//从温度显示界面跳转到参数设置界面
  93   2            {
  94   3              P_Dat[0] = P_Ctrol[0];
  95   3              P_Dat[1] = P_Ctrol[1];
  96   3            }
  97   2          break;
  98   2          case 13://参数切换
  99   2            if(Seg_Disp_Mode == 1)//处于参数设置界面
 100   2              P_Dat_Index ^= 1;
 101   2          break;
 102   2          case 16:
 103   2            P_Ctrol[0] = 30;
 104   2            P_Ctrol[1] = 20;
 105   2          break;
 106   2      //    case 14://+
 107   2      //      if(Seg_Disp_Mode == 1)//处于参数设置界面
 108   2      //      {
 109   2      //        if(++P_Dat[P_Dat_Index] == 71)
 110   2      //          P_Dat[P_Dat_Index] = 10;
 111   2      //      }
 112   2      //    break;
 113   2        }
 114   1      }
 115          
 116          /* 信息处理函数 */
C51 COMPILER V9.54   MAIN                                                                  01/06/2023 20:24:00 PAGE 3   

 117          void Seg_Proc()
 118          {
 119   1        if(Seg_Slow_Down) return;
 120   1        Seg_Slow_Down = 1;
 121   1        
 122   1        /* 信息获取区域 */
 123   1        Temperature = rd_temperature();//实时读取温度数据
 124   1        
 125   1        /* 数据显示区域 */
 126   1        switch(Seg_Disp_Mode)
 127   1        {
 128   2          case 0://温度显示界面
 129   2            Seg_Buf[0] = 11;//C
 130   2            Seg_Buf[3] = 10;
 131   2            Seg_Buf[4] = (unsigned char)Temperature / 10 % 10;
 132   2            Seg_Buf[5] = (unsigned char)Temperature % 10;
 133   2            Seg_Buf[6] = (unsigned int)(Temperature * 10) % 10;
 134   2            Seg_Buf[7] = 11;
 135   2            Seg_Point[5] = 1;
 136   2          break;
 137   2          case 1://参数设置界面
 138   2            Seg_Buf[0] = 12;//P
 139   2            Seg_Buf[3] = P_Dat[0] / 10 % 10;
 140   2            Seg_Buf[4] = P_Dat[0] % 10;
 141   2            Seg_Buf[5] = 13;//-
 142   2            Seg_Buf[6] = P_Dat[1] / 10 % 10;
 143   2            Seg_Buf[7] = P_Dat[1] % 10; 
 144   2      //      if(P_Dat_Index == 0)
 145   2      //      {
 146   2      //        Seg_Buf[3] = Seg_Star_Flag?P_Dat[0] / 10 % 10:10;
 147   2      //        Seg_Buf[4] = Seg_Star_Flag?P_Dat[0] % 10:10;
 148   2      //      }
 149   2      //      else
 150   2      //      {
 151   2      //        Seg_Buf[6] = Seg_Star_Flag?P_Dat[1] / 10 % 10:10;
 152   2      //        Seg_Buf[7] = Seg_Star_Flag?P_Dat[1] % 10:10;        
 153   2      //      }
 154   2            Seg_Buf[3*(P_Dat_Index+1)] = Seg_Star_Flag?P_Dat[P_Dat_Index] / 10 % 10:10;
 155   2            Seg_Buf[3*(P_Dat_Index+1)+1] = Seg_Star_Flag?P_Dat[P_Dat_Index] % 10:10;          
 156   2            Seg_Point[5] = 0;   
 157   2          break;
 158   2        }
 159   1        
 160   1      }
 161          
 162          /* 其他显示函数 */
 163          void Led_Proc()
 164          {
 165   1      }
 166          
 167          /* 定时器0初始化函数 */
 168          void Timer0Init(void)   //1毫秒@12.000MHz
 169          {
 170   1        AUXR &= 0x7F;   //定时器时钟12T模式
 171   1        TMOD &= 0xF0;   //设置定时器模式
 172   1        TL0 = 0x18;   //设置定时初始值
 173   1        TH0 = 0xFC;   //设置定时初始值
 174   1        TF0 = 0;    //清除TF0标志
 175   1        TR0 = 1;    //定时器0开始计时
 176   1        ET0 = 1;
 177   1        EA = 1;
 178   1      }
C51 COMPILER V9.54   MAIN                                                                  01/06/2023 20:24:00 PAGE 4   

 179          
 180          /* 定时器0中断服务函数 */
 181          void Timer0Server() interrupt 1
 182          {
 183   1        if(++Key_Slow_Down == 10) Key_Slow_Down = 0;
 184   1        if(++Seg_Slow_Down == 500) Seg_Slow_Down = 0;
 185   1        if(++Seg_Pos == 8) Seg_Pos = 0;
 186   1        Seg_Disp(Seg_Pos,Seg_Buf[Seg_Pos],Seg_Point[Seg_Pos]);
 187   1        
 188   1        if(++Timer_500MS == 500)
 189   1        {
 190   2          Timer_500MS = 0;
 191   2          Seg_Star_Flag ^= 1;
 192   2        }
 193   1        if(Key_Flag == 1)
 194   1        {
 195   2          if(++Key_Time == 600)
 196   2            Key_Time = 600;
 197   2        }
 198   1        if(++Led_Pwm == 12) Led_Pwm = 12;
 199   1        if(Led_Pwm < Level)
 200   1          Led_Disp(Seg_Pos,ucLed[Seg_Pos]);
 201   1        eles
 202   1          Led_Disp(Seg_Pos,0);
*** ERROR C202 IN LINE 202 OF main.c: 'eles': undefined identifier
*** ERROR C141 IN LINE 202 OF main.c: syntax error near 'Led_Disp'
 203   1      }
 204          
 205          /* 延时函数 */
 206          void Delay750ms()   //@12.000MHz
 207          {
 208   1        unsigned char i, j, k;
 209   1        i = 35;
 210   1        j = 51;
 211   1        k = 182;
 212   1        do
 213   1        {
 214   2          do
 215   2          {
 216   3            while (--k);
 217   3          } while (--j);
 218   2        } while (--i);
 219   1      }
 220          
 221          
 222          /* Main */
 223          void main()
 224          {
 225   1        rd_temperature();
 226   1        Delay750ms();
 227   1        Sys_Init();
 228   1        Timer0Init();
 229   1        while(1)
 230   1        {
 231   2          Key_Proc();
 232   2          Seg_Proc();
 233   2          Led_Proc();
 234   2        }
 235   1      }

C51 COMPILATION COMPLETE.  0 WARNING(S),  2 ERROR(S)
