C51 COMPILER V9.54   MAIN                                                                  11/25/2022 16:51:24 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\Driver) DEBUG OBJECTEXTEND PRI
                    -NT(.\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          /* 头文件声明区 */
   2          #include <REGX52.H>//单片机寄存器专用头文件
   3          #include <Key.h>//按键底层驱动专用头文件
   4          #include <Seg.h>//数码管底层驱动专用头文件
   5          #include <Led.h>//Led底层驱动专用头文件
   6          
   7          /* 变量声明区 */
   8          unsigned char Key_Val,Key_Down,Key_Old;//按键专用变量
   9          unsigned char Key_Slow_Down;//按键减速专用变量
  10          unsigned char Seg_Buf[6] = {10,10,10,10,10,10};//数码管显示数据存放数组
  11          unsigned char Seg_Pos;//数码管扫描专用变量
  12          unsigned int Seg_Slow_Down;//数码管减速专用变量
  13          unsigned char Seg_Disp_Mode;//数码管显示模式标志位 0-电压采集 1-数据显示 2-参数设置 
             -3-计数统计
  14          unsigned char Seg_Input[4] = {11,11,11,11};//数码管输入数据储存数组
  15          unsigned char Seg_Input_Index;//数码管输入数据储存数组指针
  16          unsigned int Timer_500Ms;//五百毫秒计时变量
  17          unsigned char Seg_Point[6] = {0,0,0,0,0,0};//数码管小数点显示数组
  18          unsigned char ucLed[6] = {0,0,0,0,0,0};//Led显示数据存放数组
  19          unsigned int Count;// 计数值专用变量
  20          unsigned int Sys_Tick;//系统计时器
  21          unsigned char Key_Error_Count;//无效按键统计变量
  22          float Voltage;//实际电压变量
  23          float Voltage_Parameter = 3.0;//电压设置参数
  24          float Voltage_Parameter_Ctrol = 3.0;//实际电压设置参数  默认值3.0V
  25          bit Seg_Flag;//数码管闪烁标志位
  26          bit Voltage_Flag ;//电压参考标志位
  27          
  28          /* 键盘处理函数 */
  29          void Key_Proc()
  30          {
  31   1        unsigned char i;//用于For循环
  32   1        if(Key_Slow_Down) return;
  33   1        Key_Slow_Down = 1;//键盘减速程序
  34   1      
  35   1        Key_Val = Key_Read();//实时读取键码值
  36   1        Key_Down = Key_Val & (Key_Old ^ Key_Val);//捕捉按键下降沿
  37   1        Key_Old = Key_Val;//辅助扫描变量
  38   1        
  39   1        if(Key_Down >= 1 && Key_Down <= 10)//键盘使能条件
  40   1        {
  41   2          if(Seg_Disp_Mode == 0 && Seg_Input_Index < 4)
  42   2          {
  43   3            Seg_Input[Seg_Input_Index] = Key_Down - 1;
  44   3            Seg_Input_Index++;
  45   3            Key_Error_Count = 0;
  46   3          }
  47   2          else
  48   2            Key_Error_Count++;
  49   2        }
  50   1        
  51   1        switch(Key_Down)
  52   1        {
  53   2          case 11:
C51 COMPILER V9.54   MAIN                                                                  11/25/2022 16:51:24 PAGE 2   

  54   2            Key_Error_Count = 0;
  55   2            if(Seg_Disp_Mode == 0)//处于电压采集界面
  56   2            {
  57   3              if(Seg_Input_Index >= 4)//判断数据有效性
  58   3              {
  59   4                Voltage = (Seg_Input[0] * 1000 + Seg_Input[1] * 100 + Seg_Input[2] * 10 + Seg_Input[3] + 5) / 1000.0;
  60   4                if(Voltage > 0)
  61   4                  Seg_Disp_Mode = 1;//跳转到数据显示界面
  62   4                else
  63   4                {
  64   5                  Seg_Input_Index = 0;//输入指针复位
  65   5                  for(i = 0;i < 4;i++)//输入数组复位
  66   5                    Seg_Input[i] = 11;
  67   5                }
  68   4              }
  69   3              else
  70   3              {
  71   4                Seg_Input_Index = 0;//输入指针复位
  72   4                for(i = 0;i < 4;i++)//输入数组复位
  73   4                  Seg_Input[i] = 11;
  74   4              }
  75   3            }
  76   2            else//处于非电压采集界面
  77   2            {
  78   3              Seg_Disp_Mode = 0;//跳转到电压采集界面
  79   3              Seg_Input_Index = 0;//输入指针复位
  80   3              for(i = 0;i < 4;i++)//输入数组复位
  81   3                Seg_Input[i] = 11;
  82   3            }
  83   2          break;
  84   2          case 12:
  85   2            if(Seg_Disp_Mode != 0)//处于非电压采集界面
  86   2            {
  87   3              Key_Error_Count = 0;
  88   3              if(Seg_Disp_Mode == 2)
  89   3                Voltage_Parameter = Voltage_Parameter_Ctrol;//保存当前设置参数
  90   3              if(++Seg_Disp_Mode == 4)
  91   3                Seg_Disp_Mode = 1;
  92   3            }
  93   2            else
  94   2              Key_Error_Count++;
  95   2          break;
  96   2          case 15:
  97   2            if(Seg_Disp_Mode == 2)//处于参数设置界面
  98   2            {
  99   3              Key_Error_Count = 0;
 100   3              Voltage_Parameter += 0.5;
 101   3              if(Voltage_Parameter > 6)
 102   3                Voltage_Parameter = 1;
 103   3            }
 104   2            else
 105   2              Key_Error_Count++;
 106   2          break;
 107   2          case 16:
 108   2            if(Seg_Disp_Mode == 2)//处于参数设置界面
 109   2            {
 110   3              Key_Error_Count = 0;
 111   3              Voltage_Parameter -=0.5;
 112   3              if(Voltage_Parameter < 1)
 113   3                Voltage_Parameter = 6;
 114   3            }
 115   2            else
C51 COMPILER V9.54   MAIN                                                                  11/25/2022 16:51:24 PAGE 3   

 116   2              Key_Error_Count++;
 117   2          break;
 118   2          case 14:
 119   2            if(Seg_Disp_Mode == 0)
 120   2            {
 121   3              Key_Error_Count = 0;
 122   3              Seg_Input_Index = 0;//输入指针复位
 123   3              for(i = 0;i < 4;i++)//输入数组复位
 124   3                Seg_Input[i] = 11;
 125   3            }
 126   2            else if(Seg_Disp_Mode == 3)
 127   2            {
 128   3              Key_Error_Count = 0;
 129   3              Count = 0;
 130   3            }
 131   2            else
 132   2              Key_Error_Count++;
 133   2          break;
 134   2        }
 135   1      }
 136          
 137          /* 信息处理函数 */
 138          void Seg_Proc()
 139          {
 140   1        unsigned char i;//用于For循环
 141   1        unsigned char j = 1;//用于While循环
 142   1        if(Seg_Slow_Down) return;
 143   1        Seg_Slow_Down = 1;//数码管减速程序
 144   1        
 145   1        if(Voltage > Voltage_Parameter_Ctrol)//当实际电压大于参考电压时
 146   1          Voltage_Flag = 1;//拉高标志位
 147   1        else if(Voltage_Flag == 1)
 148   1        {
 149   2          Voltage_Flag = 0;//标志位复位
 150   2          Count++;//计数值+1
 151   2        }
 152   1        switch(Seg_Disp_Mode)
 153   1        {
 154   2          case 0://电压采集界面
 155   2            Seg_Point[3+(int)Voltage/10] = 0;
 156   2            Seg_Buf[0] = Seg_Buf[1] = 10;
 157   2            for(i = 0;i< 4;i++)
 158   2              Seg_Buf[2+i] = Seg_Input[i];
 159   2            if(Seg_Buf[5] == 11)//只有当最后一位为-时 才实现数码管闪烁功能
 160   2              Seg_Buf[2+Seg_Input_Index] = Seg_Flag?Seg_Input[Seg_Input_Index]:10;
 161   2          break;
 162   2          case 1://数据显示界面
 163   2            Seg_Point[3+(int)Voltage/10] = 1;
 164   2            Seg_Buf[0] = 12;
 165   2            Seg_Buf[1] = Seg_Buf[2] = 10;
 166   2            Seg_Buf[3] = (int)Voltage/10?1:(unsigned char)Voltage % 10;
 167   2            Seg_Buf[4] = (unsigned int)(Voltage * 100) / 10 % 10;
 168   2            Seg_Buf[5] = (unsigned int)(Voltage * 100) % 10;
 169   2          break;
 170   2          case 2://参数设置界面
 171   2            Seg_Point[3+(int)Voltage/10] = 1;
 172   2            Seg_Buf[0] = 13;
 173   2            Seg_Buf[1] = Seg_Buf[2] = 10;
 174   2            Seg_Buf[3] = (unsigned char)Voltage_Parameter % 10;
 175   2            Seg_Buf[4] = (unsigned int)(Voltage_Parameter * 100) / 10 % 10;
 176   2            Seg_Buf[5] = (unsigned int)(Voltage_Parameter * 100) % 10;      
 177   2          break;
C51 COMPILER V9.54   MAIN                                                                  11/25/2022 16:51:24 PAGE 4   

 178   2          case 3://计数统计界面
 179   2            Seg_Point[3+(int)Voltage/10] = 0;
 180   2            Seg_Buf[0] = 14;
 181   2            Seg_Buf[1] = Count / 10000 % 10;
 182   2            Seg_Buf[2] = Count / 1000 % 10;
 183   2            Seg_Buf[3] = Count / 100 % 10;
 184   2            Seg_Buf[4] = Count / 10 % 10;
 185   2            Seg_Buf[5] = Count % 10;
 186   2            while(Seg_Buf[j] == 0)
 187   2            {
 188   3              Seg_Buf[j] = 10;
 189   3              if(++j == 5) break;
 190   3            }
 191   2          break;
 192   2        }
 193   1      }
 194          
 195          /* 其他显示函数 */
 196          void Led_Proc()
 197          {
 198   1        if(Voltage < Voltage_Parameter_Ctrol)
 199   1        {
 200   2          if(Sys_Tick >= 5000)
 201   2            ucLed[0] = 1;
 202   2        }
 203   1        else
 204   1        {
 205   2          Sys_Tick = ucLed[0] = 0;
 206   2        }
 207   1        ucLed[1] = Count % 2;
 208   1        ucLed[2] = Key_Error_Count / 3;
 209   1      }
 210          
 211          /* 定时器0中断初始化函数 */
 212          void Timer0Init(void)   //1毫秒@12.000MHz
 213          {
 214   1        TMOD &= 0xF0;   //设置定时器模式
 215   1        TMOD |= 0x01;   //设置定时器模式
 216   1        TL0 = 0x18;   //设置定时初始值
 217   1        TH0 = 0xFC;   //设置定时初始值
 218   1        TF0 = 0;    //清除TF0标志
 219   1        TR0 = 1;    //定时器0开始计时
 220   1        ET0 = 1;    //定时器0中断打开
 221   1        EA = 1;     //总中断打开
 222   1      }
 223          
 224          /* 定时器0中断服务函数 */
 225          void Timer0Server() interrupt 1
 226          {
 227   1        TL0 = 0x18;   //设置定时初始值
 228   1        TH0 = 0xFC;   //设置定时初始值   
 229   1        if(++Key_Slow_Down == 10) Key_Slow_Down = 0;//键盘减速专用
 230   1        if(++Seg_Slow_Down == 500) Seg_Slow_Down = 0;//数码管减速专用
 231   1        if(++Seg_Pos == 6) Seg_Pos = 0;//数码管显示专用
 232   1        Seg_Disp(Seg_Pos,Seg_Buf[Seg_Pos],Seg_Point[Seg_Pos]);
 233   1        Led_Disp(Seg_Pos,ucLed[Seg_Pos]);
 234   1        if(Voltage < Voltage_Parameter_Ctrol)
 235   1          Sys_Tick++;
 236   1        if(++Timer_500Ms == 500)
 237   1        {
 238   2          Timer_500Ms = 0;
 239   2          Seg_Flag ^= 1;
C51 COMPILER V9.54   MAIN                                                                  11/25/2022 16:51:24 PAGE 5   

 240   2        }
 241   1      }
 242          
 243          /* Main */
 244          void main()
 245          {
 246   1        Timer0Init();
 247   1        while (1)
 248   1        {
 249   2          Key_Proc();
 250   2          Seg_Proc();
 251   2          Led_Proc();
 252   2        }
 253   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1277    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     50       2
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
