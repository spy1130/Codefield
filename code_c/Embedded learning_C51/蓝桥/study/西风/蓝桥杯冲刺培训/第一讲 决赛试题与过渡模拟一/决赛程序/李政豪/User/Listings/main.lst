C51 COMPILER V9.54   MAIN                                                                  11/20/2022 17:39:51 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\Driver) DEBUG OBJECTEXTEND PRI
                    -NT(.\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          /* 第二届 创意智造·奠基未来 单片机设计与开发大赛 专用模板 */
   2           
   3          /* 头文件声明区 */
   4          #include <REGX52.H>//单片机寄存器专用头文件
   5          #include <Key.h>//按键底层驱动专用头文件
   6          #include <Seg.h>//数码管底层驱动专用头文件
   7          #include <intrins.h>//LED移动函数库
   8          
   9          /* 变量声明区 */
  10          unsigned char Key_Val,Key_Down,Key_Old;//按键专用变量
  11          unsigned char Key_Slow_Down;//按键减速专用变量
  12          unsigned char Seg_Buf[6] = {10,10,10,10,10,10};//数码管显示数据存放数组
  13          unsigned char Seg_Pos;//数码管扫描专用变量
  14          unsigned int Seg_Slow_Down;//数码管减速专用变量
  15          unsigned char Seg_Disp_Mobe;//数码管的三种模式 0-运行模式 1-设置模式 2-数据显示界面
  16          unsigned char Seg_Come[6]={12,1,10,4,0,0};//运行模式1
  17          unsigned char Seg_Come_Index=0;//运行指针
  18          unsigned char Seg_Setting[6]={14,1,10,4,0,0};//设置界面数组
  19          unsigned char Seg_Setting_Index=0;//数组指针
  20          unsigned int  Time_400ms;//时间400ms延迟
  21          unsigned char LED_Flood;//流动变量
  22          unsigned char LED_First=0xfe;//模式1-LED
  23          unsigned char LED_Second=0x7f;//模式2-LED
  24          unsigned char LED_3[4]={0x7e,0xbd,0xdb,0xe7};//模式3-LED
  25          unsigned char LED_3x=0xff;//模式3
  26          unsigned char Try;//次数
  27          unsigned char LED_4[4]={0xe7,0xdb,0xbd,0x7e};//模式4-LED
  28          unsigned char LED_4x=0xff;//模式4
  29          unsigned int  Time_Delay;//时间延迟变量
  30          unsigned int  Time_Arrive;//时间到达变量
  31          bit Key_6;//按键6按下
  32          bit Seg_Degin;//运行模式开始计时
  33          bit Seg_Setting_Flash;//设置模式闪烁
  34          
  35          /* 键盘处理函数 */
  36          void Key_Proc()
  37          {
  38   1        unsigned char Move;                                //流动变量
  39   1        
  40   1        if(Key_Slow_Down) return;
  41   1        Key_Slow_Down = 1;//键盘减速程序
  42   1      
  43   1        Key_Val = Key_Read();//实时读取键码值
  44   1        Key_Down = Key_Val & (Key_Old ^ Key_Val);//捕捉按键下降沿
  45   1        Key_Old = Key_Val;//辅助扫描变量
  46   1      
  47   1        
  48   1        switch(Key_Down)
  49   1        {
  50   2      /*------------------切换按键-------------------------*/   
  51   2          case 6 :                                          //按键6按下可以在运行模式和流动间隔模式切换
  52   2          LED_Flood=0;                                      //关闭LED流动
  53   2          P1=0xff;                                          //开启设置模式关闭所有LED
  54   2          Seg_Disp_Mobe=1;
C51 COMPILER V9.54   MAIN                                                                  11/20/2022 17:39:51 PAGE 2   

  55   2          Key_6=1;
  56   2          if(LED_Flood==0)
  57   2        { switch(Seg_Setting_Index)
  58   3          {                                                 //切换到设置模式
  59   4            case 0 :                                        //运行模式
  60   4            Seg_Setting_Index=1;                            //切换到流动模式
  61   4            break;
  62   4            
  63   4            case 1 :
  64   4            Seg_Setting_Index=0;                            //切换到运行模式   
  65   4            break;
  66   4          }
  67   3        }
  68   2          break;
  69   2      /*-----------------加速按键--------------------------*/   
  70   2           case 5 :                                         //按键5进入加速模式
  71   2            if(Seg_Disp_Mobe==1)
  72   2            {
  73   3              switch(Seg_Setting_Index)
  74   3              {
  75   4                case 0 :                                    //加速模式若选中运行模式                                           
             -         
  76   4                if(++Seg_Setting[1]==5)                     //个位加到5
  77   4                  Seg_Setting[1]=1;
  78   4                break;
  79   4                
  80   4                case 1 :                                    //加速模式选中在流动间隔模式
  81   4                if(++Seg_Setting[3]==10)
  82   4                {
  83   5                  Seg_Setting[2]=1;
  84   5                  Seg_Setting[3]=0;
  85   5                }
  86   4                if(Seg_Setting[2]==1 && Seg_Setting[3]>2)  //固定到12
  87   4                {
  88   5                  Seg_Setting[2]=1;
  89   5                  Seg_Setting[3]=2;
  90   5                }
  91   4                break;
  92   4              }
  93   3            }break;
  94   2      /*----------------减速按键------------------------------*/  
  95   2            case 4 :                                          //按键4进入减速模式
  96   2            if(Seg_Disp_Mobe==1)
  97   2            {
  98   3              switch(Seg_Setting_Index)
  99   3              {
 100   4                case 0 :                                      //减速模式选中运行模式
 101   4                if(--Seg_Setting[1]==0)
 102   4                  Seg_Setting[1]=4;
 103   4                break;
 104   4                
 105   4                case 1 :
 106   4                  if(Seg_Setting[2]==1)                       //如果十位为1
 107   4                {
 108   5                  if(--Seg_Setting[3]==255)                   //将十位化为10
 109   5                  {Seg_Setting[2]=10;
 110   6                  Seg_Setting[3]=9;}
 111   5                }
 112   4                else
 113   4                  if(--Seg_Setting[3]<4)                      //固定到4
 114   4                   Seg_Setting[3]=4;      
 115   4                break;
C51 COMPILER V9.54   MAIN                                                                  11/20/2022 17:39:51 PAGE 3   

 116   4              }
 117   3            }break;
 118   2      /*----按键7为“启动/停止按键,按下后启动或停止LED------*/
 119   2      
 120   2            case 7 : 
 121   2            Seg_Disp_Mobe=0;                                 //按下后回到运行模式
 122   2            switch(LED_Flood)
 123   2            {
 124   3              case 0 :                                       //LED还没有流动
 125   3              for(Move=1;Move<4;Move++)
 126   3              Seg_Come[Move]=Seg_Setting[Move];              //赋值
 127   3      //        Seg_Come[1]=Seg_Setting[1];                  
 128   3      //        Seg_Come[2]=Seg_Setting[2];
 129   3      //        Seg_Come[3]=Seg_Setting[3];
 130   3              LED_Flood=1;                                   //切换到流动模式
 131   3              Seg_Come[0]=11;                                //流动标志位
 132   3              break;
 133   3              
 134   3              case 1 :                                       //LED流动模式
 135   3              Seg_Come[0]=12;                                //停止标志位
 136   3              LED_Flood=0;
 137   3              break;      
 138   3            }
 139   2              break;
 140   2        }
 141   1      }
 142          
 143          /* 信息处理函数 */
 144          void Seg_Proc()
 145          {
 146   1        unsigned char Cycle;  //移动变量
 147   1        if(Seg_Slow_Down) return;
 148   1        Seg_Slow_Down = 1;//数码管减速程序
 149   1        
 150   1        switch(Seg_Disp_Mobe)
 151   1        {
 152   2          case 0 :         //运行模式
 153   2          for(Cycle=0;Cycle<6;Cycle++)
 154   2          Seg_Buf[Cycle]=Seg_Come[Cycle];
 155   2          break;
 156   2          
 157   2          case 1 :        //设置模式
 158   2          for(Cycle=0;Cycle<6;Cycle++)
 159   2          Seg_Buf[Cycle]=Seg_Setting[Cycle];
 160   2                          //闪烁位
 161   2          if(Seg_Setting_Index==0)
 162   2          {
 163   3          Seg_Buf[0]=Seg_Setting_Flash?10:Seg_Setting[0];
 164   3          Seg_Buf[1]=Seg_Setting_Flash?10:Seg_Setting[1];
 165   3          }
 166   2          
 167   2          if(Seg_Setting_Index==1)
 168   2          {
 169   3            for(Cycle=2;Cycle<6;Cycle++)
 170   3            Seg_Buf[Cycle]=Seg_Setting_Flash?10:Seg_Setting[Cycle];
 171   3          }
 172   2          break;
 173   2            
 174   2      
 175   2        }
 176   1      }
 177          
C51 COMPILER V9.54   MAIN                                                                  11/20/2022 17:39:51 PAGE 4   

 178          /* 其他显示函数 */
 179          void Led_Proc()
 180          {
 181   1                                                                        //模式1
 182   1        if(Seg_Disp_Mobe==0 && Seg_Come[1]==1 && LED_Flood==1)
 183   1        P1=LED_First;
 184   1                                                                        //模式2
 185   1        if(Seg_Disp_Mobe==0 && Seg_Come[1]==2 && LED_Flood==1)
 186   1        P1=LED_Second;
 187   1                                                                        //模式3
 188   1        if(Seg_Disp_Mobe==0 && Seg_Come[1]==3 && LED_Flood==1)
 189   1        P1=LED_3x;
 190   1                                                                        //模式4
 191   1        if(Seg_Disp_Mobe==0 && Seg_Come[1]==4 && LED_Flood==1)
 192   1        P1=LED_4x;
 193   1      }
 194          
 195          /* 定时器0中断初始化函数 */
 196          void Timer0Init(void)   //1毫秒@12.000MHz
 197          {
 198   1        TMOD &= 0xF0;   //设置定时器模式
 199   1        TMOD |= 0x01;   //设置定时器模式
 200   1        TL0 = 0x18;   //设置定时初始值
 201   1        TH0 = 0xFC;   //设置定时初始值
 202   1        TF0 = 0;    //清除TF0标志
 203   1        TR0 = 1;    //定时器0开始计时
 204   1        ET0 = 1;        //定时器0中断打开
 205   1        EA = 1;         //总中断打开
 206   1      }
 207          
 208          /* 定时器0中断服务函数 */
 209          void Timer0Server() interrupt 1
 210          {
 211   1        unsigned char Run;//移动变量
 212   1        
 213   1        TL0 = 0x18;   //设置定时初始值
 214   1        TH0 = 0xFC;   //设置定时初始值   
 215   1        if(++Key_Slow_Down == 10) Key_Slow_Down = 0;//键盘减速专用
 216   1        if(++Seg_Slow_Down == 500) Seg_Slow_Down = 0;//数码管减速专用
 217   1        
 218   1        if(++Seg_Pos == 6) Seg_Pos = 0;//数码管显示专用
 219   1        Seg_Disp(Seg_Pos,Seg_Buf[Seg_Pos]);
 220   1      /*---------------设置模式闪烁------------*/ 
 221   1        if(Key_6==1)
 222   1        {
 223   2          if(++Time_400ms==400)
 224   2          {
 225   3            Time_400ms=0;
 226   3              Seg_Setting_Flash=~Seg_Setting_Flash;
 227   3            }
 228   2          }
 229   1      /*---------------LED模式1------------------*/ 
 230   1        if(Seg_Disp_Mobe==0 && Seg_Come[1]==1 && LED_Flood==1)
 231   1        {
 232   2          if(Seg_Come[2]==1)                           //如果为1
 233   2          Time_Delay=Seg_Come[2]*1000+Seg_Come[3]*100;
 234   2          if(Seg_Come[2]==10)
 235   2          Time_Delay=Seg_Come[3]*100;
 236   2          if(++Time_Arrive==Time_Delay)
 237   2          {
 238   3            Time_Arrive=0;
 239   3            LED_First=_crol_(LED_First,1);             //移动
C51 COMPILER V9.54   MAIN                                                                  11/20/2022 17:39:51 PAGE 5   

 240   3          }
 241   2        }
 242   1      /*--------------LED模式2--------------------*/
 243   1        if(Seg_Disp_Mobe==0 && Seg_Come[1]==2 && LED_Flood==1)
 244   1        {
 245   2          if(Seg_Come[2]==1)                           //如果为1
 246   2          Time_Delay=Seg_Come[2]*1000+Seg_Come[3]*100;
 247   2          if(Seg_Come[2]==10)
 248   2          Time_Delay=Seg_Come[3]*100;
 249   2          if(++Time_Arrive==Time_Delay)
 250   2          {
 251   3            Time_Arrive=0;
 252   3            LED_Second=_cror_(LED_Second,1);             //移动
 253   3          }     
 254   2        }
 255   1      /*------------LED模式3------------------------*/
 256   1        if(Seg_Disp_Mobe==0 && Seg_Come[1]==3 && LED_Flood==1)
 257   1        {
 258   2          if(Seg_Come[2]==1)                           //如果为1
 259   2          Time_Delay=Seg_Come[2]*1000+Seg_Come[3]*100;
 260   2          if(Seg_Come[2]==10)
 261   2          Time_Delay=Seg_Come[3]*100;
 262   2          if(++Time_Arrive==Time_Delay)
 263   2          {
 264   3            Time_Arrive=0;
 265   3            ++Try;
 266   3            switch(Try)
 267   3            {
 268   4              case 1 :
 269   4              LED_3x=LED_3[0];
 270   4              break;
 271   4              
 272   4              case 2 :
 273   4              LED_3x=LED_3[1];
 274   4              break;
 275   4              
 276   4              case 3 :
 277   4              LED_3x=LED_3[2];
 278   4              break;
 279   4              
 280   4              case 4 :
 281   4              LED_3x=LED_3[3];
 282   4              break;
 283   4          }
 284   3            if(Try==4)
 285   3              Try=0;
 286   3          }
 287   2        }
 288   1      /*-----------------LED模式4---------------------------*/
 289   1        if(Seg_Disp_Mobe==0 && Seg_Come[1]==4 && LED_Flood==1)
 290   1        {
 291   2          if(Seg_Come[2]==1)                           //如果为1
 292   2          Time_Delay=Seg_Come[2]*1000+Seg_Come[3]*100;
 293   2          if(Seg_Come[2]==10)
 294   2          Time_Delay=Seg_Come[3]*100;
 295   2          if(++Time_Arrive==Time_Delay)
 296   2          {
 297   3            Time_Arrive=0;
 298   3            ++Try;
 299   3            switch(Try)
 300   3            {
 301   4              case 1 :
C51 COMPILER V9.54   MAIN                                                                  11/20/2022 17:39:51 PAGE 6   

 302   4              LED_4x=LED_4[0];
 303   4              break;
 304   4              
 305   4              case 2 :
 306   4              LED_4x=LED_4[1];
 307   4              break;
 308   4              
 309   4              case 3 :
 310   4              LED_4x=LED_4[2];
 311   4              break;
 312   4              
 313   4              case 4 :
 314   4              LED_4x=LED_4[3];
 315   4              break;
 316   4            }
 317   3            if(Try==4)
 318   3              Try=0;
 319   3          }
 320   2        }
 321   1      }
*** WARNING C280 IN LINE 211 OF main.c: 'Run': unreferenced local variable
 322          
 323          
 324          /* Main */
 325          void main()
 326          {
 327   1        Timer0Init();
 328   1        while (1)
 329   1        {
 330   2          Key_Proc();
 331   2          Seg_Proc();
 332   2          Led_Proc();
 333   2        }
 334   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1088    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     48       1
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      3    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
