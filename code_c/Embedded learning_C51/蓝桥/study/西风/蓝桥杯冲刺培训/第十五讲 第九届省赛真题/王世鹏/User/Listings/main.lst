C51 COMPILER V9.54   MAIN                                                                  02/03/2023 19:48:40 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\Keil5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\Driver) DEBUG OBJECTEXTEND PRINT
                    -(.\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          /*头文件声明区*//**/
   2          #include <STC15F2K60S2.H>
   3          #include <Init.h>
   4          #include "iic.h"
   5          #include <Key.h>
   6          #include <Seg.h>
   7          #include <Led.h>
   8          /*用户自定义区*/
   9          typedef unsigned char u8;/*重定义*/
  10          typedef unsigned int u16;
  11          u8 Key_Show_Down,Seg_Show_Down;/*减速专用*/
  12          u8 Key_Val,Key_Down,Key_Old;/*按键专用*/
  13          u8 Seg_Pos;/*数码管显示位*/
  14          u8 Seg_Buf[8]={0,1,1,1,2,2,3,4};/*数码管显示数据存放数组*/
  15          u8 Seg_Set;/*为0熄灭数码管*//*为1改变Led模式*//*为2改变间隔*//**/
  16          u8 i;/*循环LED点亮*/
  17          u8 Timera_Max[8]={4,4,4,4,1,1,1,1};/*流转间隔值*/
  18          u8 Timerb_Max[4]={4,4,4,4};/*流转间隔改变值*/
  19          u8 Led_Pwm=2;/*PWM比较值*//*Led亮度等级*/
  20          char Led_Mode_a,Led_Mode_b;/*Led模式以及改变模式值*/
  21          float Rb2;/*模拟电压值*/
  22          bit Seg_Mode;/*数码管模式*/
  23          bit Start;/*为1点亮Led*/
  24          bit Begin;/*为1Led启动,为0停止*/
  25          bit Glimmer;/*闪烁标志位*/
  26          /*用户自定义结束*/
  27          
  28          /*键盘处理函数*/
  29          void Key_Proc()
  30          {
  31   1        u8 j;/*循环专用*/
  32   1        if(Key_Show_Down)return;
  33   1        Key_Show_Down=1;/*按键减速*/
  34   1        Key_Val=Key_Read();/*获取键码值*/
  35   1        Key_Down=Key_Val&(Key_Val^Key_Old);/*捕捉下降沿*/
  36   1        Key_Old=Key_Val;/*辅助扫描*/
  37   1        switch(Key_Down)
  38   1        {
  39   2          case 4:
  40   2            if(Seg_Set==1)/*Led模式减小*/
  41   2              {if(--Led_Mode_b<0)Led_Mode_b=3;}
  42   2            else if(Seg_Set==2){/*流转间隔减小*/
  43   3              if(--Timerb_Max[Led_Mode_b]<4)Timerb_Max[Led_Mode_b]=12;}
  44   2          break;
  45   2          case 5:
  46   2            if(Seg_Set==1)/*Led模式增加*/
  47   2              {if(++Led_Mode_b>3)Led_Mode_b=0;}
  48   2            else if(Seg_Set==2){/*流转间隔增加*/
  49   3              if(++Timerb_Max[Led_Mode_b]>12)Timerb_Max[Led_Mode_b]=4;}
  50   2          break;
  51   2          case 6:/*改变修改位*/
  52   2            if(++Seg_Set==3)Seg_Set=0;
  53   2            if(Seg_Set==1)/*Led模式切换*/
  54   2              {
C51 COMPILER V9.54   MAIN                                                                  02/03/2023 19:48:40 PAGE 2   

  55   3                Led_Mode_b=Led_Mode_a;/*获取当前Led模式*/
  56   3                for(j=0;j<4;j++)
  57   3                Timerb_Max[j]=Timera_Max[j];/*获取Led流转间隔*/
  58   3              }
  59   2            else if(Seg_Set==0)
  60   2              {
  61   3                for(j=0;j<8;j++)
  62   3                {
  63   4                  if(j<4)
  64   4                  Timera_Max[j]=Timerb_Max[j];/*获取改变的间隔值*/
  65   4                  Led_Disp(j,0);/*熄灭Led*//*便于Led显示*/
  66   4                }
  67   3                i=0;/*Led点亮位复位*/
  68   3                Led_Mode_a=Led_Mode_b;/*获取改变的模式*/
  69   3                EEPROM_Write(Timera_Max,0,8);/*将改变间隔值保存在EEPROM中*/
  70   3              }
  71   2          break;
  72   2          case 7:
  73   2            Start=1;/*点亮Led*/
  74   2            Begin=~Begin;/*启动或停止Led*/
  75   2          break;
  76   2        }
  77   1        if(Seg_Set==0&&Key_Old==4)/*长按S4*/
  78   1          Seg_Mode=1;/*显示Led亮度等级*/
  79   1        else
  80   1          Seg_Mode=0;
  81   1      }
  82          /*数码管处理函数*/
  83          void Seg_Proc()
  84          {
  85   1        u8 j;
  86   1        if(Seg_Show_Down)return;
  87   1        Seg_Show_Down=1;
  88   1        Rb2=Ad_Read(0x43)/51.0;/*获取模拟电压值*/
  89   1        if(Rb2>=0&&Rb2<=1.25)Led_Pwm=2;/*亮度等级1*/
  90   1        else if(Rb2>1.25&&Rb2<=2.5)Led_Pwm=4;/*亮度等级2*/
  91   1        else if(Rb2>2.5&&Rb2<=3.75)Led_Pwm=6;/*亮度等级3*/
  92   1        else if(Rb2>3.75&&Rb2<=5.0)Led_Pwm=8;/*亮度等级4*/
  93   1        if(Seg_Mode==0){
  94   2          if(Seg_Set!=0){
  95   3            Seg_Buf[0]=(Glimmer&&Seg_Set==1)?10:11;
  96   3            Seg_Buf[1]=(Glimmer&&Seg_Set==1)?10:Led_Mode_b+1;/*显示Led模式*/
  97   3            Seg_Buf[2]=(Glimmer&&Seg_Set==1)?10:11;
  98   3            Seg_Buf[3]=10;
  99   3            if(Timerb_Max[Led_Mode_b]>=10)/*如果间隔大于等于1000ms*/
 100   3              Seg_Buf[4]=(Glimmer&&Seg_Set==2)?10:Timerb_Max[Led_Mode_b]/10;/*显示流转间隔*/
 101   3            else 
 102   3              Seg_Buf[4]=10;
 103   3              Seg_Buf[5]=(Glimmer&&Seg_Set==2)?10:Timerb_Max[Led_Mode_b]%10;
 104   3              Seg_Buf[6]=(Glimmer&&Seg_Set==2)?10:0;
 105   3              Seg_Buf[7]=(Glimmer&&Seg_Set==2)?10:0;}
 106   2          else
 107   2          {
 108   3            for(j=0;j<8;j++)
 109   3            Seg_Buf[j]=10;/*熄灭数码管*/
 110   3          }
 111   2        }
 112   1        else
 113   1        {/*长按显示亮度等级*/
 114   2          for(j=0;j<6;j++)
 115   2          Seg_Buf[j]=10;
 116   2          Seg_Buf[6]=11;
C51 COMPILER V9.54   MAIN                                                                  02/03/2023 19:48:40 PAGE 3   

 117   2          Seg_Buf[7]=Led_Pwm/2;
 118   2        }
 119   1      }
 120          /*其它处理函数*/
 121          void Led_Proc()
 122          {
 123   1        if(Start){
 124   2        switch(Led_Mode_a)
 125   2        {
 126   3          case 0:
 127   3            Led_Disp(i,1);
 128   3            if(i>0)
 129   3            Led_Disp(i-1,0);
 130   3          break;
 131   3          case 1:
 132   3            Led_Disp(7-i,1);
 133   3            if(i>0)
 134   3            Led_Disp(8-i,0);
 135   3          break;
 136   3          case 2:
 137   3            Led_Disp(i,1);Led_Disp(7-i,1);
 138   3            if(i>0&&i<=3)
 139   3            {Led_Disp(i-1,0);Led_Disp(8-i,0);}
 140   3            else if(i==4){Led_Mode_a=3;i=0;}
 141   3          break;
 142   3          case 3:
 143   3            Led_Disp(3-i,1);Led_Disp(i+4,1);
 144   3            if(i>0&&i<=3)
 145   3            {Led_Disp(4-i,0);Led_Disp(i+3,0);}
 146   3            else if(i==4){Led_Mode_a=0;i=0;Led_Disp(7,0);}
 147   3          break;
 148   3        }}
 149   1      }
 150          /*中断初始化函数*/
 151          void Timer0Init(void)   //1毫秒@12.000MHz
 152          {
 153   1        AUXR &= 0x7F;   //定时器时钟12T模式
 154   1        TMOD &= 0xF0;   //设置定时器模式
 155   1        TL0 = 0x18;   //设置定时初始值
 156   1        TH0 = 0xFC;   //设置定时初始值
 157   1        TF0 = 0;    //清除TF0标志
 158   1        TR0 = 1;    //定时器0开始计时
 159   1        ET0=1;
 160   1        EA=1;
 161   1      }
 162          /*中断服务函数*/
 163          void Timer0Server() interrupt 1
 164          {
 165   1        u8 j,Led_Num;
 166   1        u16 Timer_Min,Timer400ms;
 167   1        if(++Key_Show_Down==10)Key_Show_Down=0;/*按键减速10ms*/
 168   1        if(++Seg_Show_Down==80)Seg_Show_Down=0;/*数码管减速80ms*/
 169   1        if(++Seg_Pos==8)Seg_Pos=0;
 170   1        Seg_Disp(Seg_Pos,Seg_Buf[Seg_Pos]);
 171   1        if(Begin){/*Led启动*/
 172   2        if(++Timer_Min>=(Timera_Max[Led_Mode_a]*100))/*流转间隔*/
 173   2        {
 174   3          Timer_Min=0;
 175   3          if(++i==8){i=0;Led_Mode_a++;}/*点亮位改变*/
 176   3        }}
 177   1        if(Seg_Set!=0)/*改变值时*/
 178   1        {
C51 COMPILER V9.54   MAIN                                                                  02/03/2023 19:48:40 PAGE 4   

 179   2          if(++Timer400ms==400)/*800ms间隔闪烁*/
 180   2          {
 181   3            Timer400ms=0;
 182   3            Glimmer=~Glimmer;
 183   3          }
 184   2        }
 185   1        else
 186   1        {
 187   2          Timer400ms=0;
 188   2          Glimmer=0;/*复位*/
 189   2        }
 190   1        if(++Led_Num==10)Led_Num=0;
 191   1        if(Led_Num>Led_Pwm)/*PWM改变亮度*/
 192   1        {for(j=0;j<8;j++)Led_Disp(j,0);}
 193   1        else Led_Proc();
 194   1      }
 195          /*主函数*/
 196          void main()
 197          {
 198   1        EEPROM_Read(Timera_Max,0,8);
 199   1        System_Init();
 200   1        Timer0Init();
 201   1        while(1)
 202   1        {
 203   2          Key_Proc();
 204   2          Seg_Proc();
 205   2      //    Led_Proc();
 206   2        }
 207   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1231    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     35       8
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      4    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
